<!DOCTYPE html>
<html>
<head>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        #world {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(#e4e0ba, #f7d9aa);
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="controls">
        <p><b>조작법</b></p>
        <p>위 화살표: 기수 내리기</p>
        <p>아래 화살표: 기수 올리기</p>
        <p>왼쪽 화살표: 좌회전</p>
        <p>오른쪽 화살표: 우회전</p>
        <p>스페이스바: 부스트</p>
    </div>
    <div id="world"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/86/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.86.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.86.0/examples/js/loaders/MTLLoader.js"></script>
    <script>
        // 색상 객체: 재료의 색상 값을 일관성 있게 유지하고 쉽게 변경할 수 있도록 합니다.
        var Colors = {
            red: 0xf25346,
            yellow: 0xedeb27,
            white: 0xd8d0d1,
            brown: 0x59332e,
            pink: 0xF5986E,
            brownDark: 0x23190f,
            blue: 0x68c3c0,
            green: 0x458248,
            purple: 0x551A8B,
            lightgreen: 0x629265,
        };

        // SCENE, CAMERA, RENDERER 및 Three.js 월드의 기타 전역 변수.
        var scene, camera, fieldOfView, aspectRatio, nearPlane, farPlane, HEIGHT, WIDTH, renderer, container;

        // Three.js 씬, 카메라, 렌더러를 초기화합니다.
        function createScene() {
            // 창의 높이와 너비를 가져와 종횡비와 렌더러 크기를 설정합니다.
            HEIGHT = window.innerHeight;
            WIDTH = window.innerWidth;

            // 씬 객체를 생성합니다.
            scene = new THREE.Scene();

            // 깊이감을 위해 씬에 안개를 추가합니다. 색상은 배경과 일치합니다.
            scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);

            // 카메라의 속성을 설정합니다.
            aspectRatio = WIDTH / HEIGHT;
            fieldOfView = 60; // 시야각 (도).
            nearPlane = 1; // 렌더링될 카메라에 가장 가까운 객체.
            farPlane = 10000; // 렌더링될 카메라에서 가장 먼 객체.
            camera = new THREE.PerspectiveCamera(
                fieldOfView,
                aspectRatio,
                nearPlane,
                farPlane
            );
            
            // 카메라의 초기 위치를 설정합니다.
            camera.position.x = 0;
            camera.position.z = 200;
            camera.position.y = 100;

            // WebGL 렌더러를 생성합니다.
            renderer = new THREE.WebGLRenderer({
                alpha: true, // 투명한 배경을 허용합니다.
                antialias: true // 객체의 가장자리를 부드럽게 합니다 (성능 집약적일 수 있음).
            });

            // 렌더러의 크기를 창 크기와 일치하도록 설정합니다.
            renderer.setSize(WIDTH, HEIGHT);
            // 렌더러에서 그림자 매핑을 활성화합니다.
            renderer.shadowMap.enabled = true;

            // HTML에서 'world' div를 가져와 렌더러의 캔버스 요소를 추가합니다.
            container = document.getElementById('world');
            container.appendChild(renderer.domElement);

            // 창 크기 조정 이벤트를 처리하기 위한 이벤트 리스너를 추가합니다.
            window.addEventListener('resize', handleWindowResize, false);
        }

        // 씬의 비율을 유지하기 위해 창 크기 조정 이벤트를 처리합니다.
        function handleWindowResize() {
            HEIGHT = window.innerHeight;
            WIDTH = window.innerWidth;
            renderer.setSize(WIDTH, HEIGHT);
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix(); // 카메라 속성 변경 후 호출해야 합니다.
        }

        // 조명
        var hemisphereLight, shadowLight;

        // 씬의 조명을 설정합니다.
        function createLights() {
            // 반구형 조명은 위아래에서 부드러운 주변 조명을 제공합니다.
            hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, .9)
            
            // 방향성 조명은 평행 광선을 투사하여 햇빛을 시뮬레이션합니다.
            shadowLight = new THREE.DirectionalLight(0xffffff, .9);
            shadowLight.position.set(150, 350, 350); // 조명 위치 설정.
            shadowLight.castShadow = true; // 이 조명이 그림자를 드리우도록 활성화합니다.

            // 그림자가 보이는 영역을 정의합니다.
            shadowLight.shadow.camera.left = -400;
            shadowLight.shadow.camera.right = 400;
            shadowLight.shadow.camera.top = 400;
            shadowLight.shadow.camera.bottom = -400;
            shadowLight.shadow.camera.near = 1;
            shadowLight.shadow.camera.far = 1000;

            // 그림자 맵의 해상도를 설정합니다.
            shadowLight.shadow.mapSize.width = 2048;
            shadowLight.shadow.mapSize.height = 2048;

            // 씬에 조명을 추가합니다.
            scene.add(hemisphereLight);
            scene.add(shadowLight);
        }

        // 비행기 객체 정의.
        var AirPlane = function (callback) {
            this.mesh = new THREE.Object3D();
            var self = this; // 'this' 컨텍스트를 유지합니다.

            var mtlLoader = new THREE.MTLLoader();
            mtlLoader.setPath('airplane/'); // .mtl 파일 경로 설정
            mtlLoader.load('11803_Airplane_v1_l1.mtl', function (materials) {
                materials.preload();
                var objLoader = new THREE.OBJLoader();
                objLoader.setMaterials(materials);
                objLoader.setPath('airplane/'); // .obj 파일 경로 설정
                objLoader.load('11803_Airplane_v1_l1.obj', function (object) {
                    object.traverse(function (child) {
                        if (child instanceof THREE.Mesh) {
                            child.castShadow = true;
                            child.receiveShadow = true;
                        }
                    });
                    object.rotation.x = Math.PI / 2; // 사용자 지정 피치
                    object.rotation.y = Math.PI; // 사용자 지정 요
                    object.rotation.z = Math.PI; // 사용자 지정 롤
                    self.mesh.add(object);
                    if (callback) callback();
                });
            });
        };

        // 지면 객체 정의.
        Land = function () {
            var geom = new THREE.PlaneGeometry(20000, 20000, 1, 1);
            geom.rotateX(-Math.PI / 2); // 평면을 수평으로 회전합니다.
            var mat = new THREE.MeshPhongMaterial({
                color: Colors.lightgreen,
                shading: THREE.FlatShading,
            });
            this.mesh = new THREE.Mesh(geom, mat);
            this.mesh.receiveShadow = true; // 지면은 그림자를 받아야 합니다.
        }

        // 나무 객체 정의.
        Tree = function () {
            this.mesh = new THREE.Object3D();

            var matTreeLeaves = new THREE.MeshPhongMaterial({ color: Colors.green, shading: THREE.FlatShading });

            // 몸통을 생성합니다.
            var geonTreeBase = new THREE.BoxGeometry(10, 20, 10);
            var matTreeBase = new THREE.MeshBasicMaterial({ color: Colors.brown });
            var treeBase = new THREE.Mesh(geonTreeBase, matTreeBase);
            treeBase.castShadow = true;
            treeBase.receiveShadow = true;
            this.mesh.add(treeBase);

            // 원통을 사용하여 잎을 생성합니다.
            var geomTreeLeaves1 = new THREE.CylinderGeometry(1, 12 * 3, 12 * 3, 4);
            var treeLeaves1 = new THREE.Mesh(geomTreeLeaves1, matTreeLeaves);
            treeLeaves1.castShadow = true;
            treeLeaves1.receiveShadow = true;
            treeLeaves1.position.y = 20
            this.mesh.add(treeLeaves1);

            var geomTreeLeaves2 = new THREE.CylinderGeometry(1, 9 * 3, 9 * 3, 4);
            var treeLeaves2 = new THREE.Mesh(geomTreeLeaves2, matTreeLeaves);
            treeLeaves2.castShadow = true;
            treeLeaves2.position.y = 40;
            treeLeaves2.receiveShadow = true;
            this.mesh.add(treeLeaves2);

            var geomTreeLeaves3 = new THREE.CylinderGeometry(1, 6 * 3, 6 * 3, 4);
            var treeLeaves3 = new THREE.Mesh(geomTreeLeaves3, matTreeLeaves);
            treeLeaves3.castShadow = true;
            treeLeaves3.position.y = 55;
            treeLeaves3.receiveShadow = true;
            this.mesh.add(treeLeaves3);
        }

        // 꽃 객체 정의.
        Flower = function () {
            this.mesh = new THREE.Object3D();

            // 줄기를 생성합니다.
            var geomStem = new THREE.BoxGeometry(5, 50, 5, 1, 1, 1);
            var matStem = new THREE.MeshPhongMaterial({ color: Colors.green, shading: THREE.FlatShading });
            var stem = new THREE.Mesh(geomStem, matStem);
            stem.castShadow = false;
            stem.receiveShadow = true;
            this.mesh.add(stem);

            // 꽃의 중심을 생성합니다.
            var geomPetalCore = new THREE.BoxGeometry(10, 10, 10, 1, 1, 1);
            var matPetalCore = new THREE.MeshPhongMaterial({ color: Colors.yellow, shading: THREE.FlatShading });
            petalCore = new THREE.Mesh(geomPetalCore, matPetalCore);
            petalCore.castShadow = false;
            petalCore.receiveShadow = true;

            // 꽃잎의 무작위 색상을 선택합니다.
            var petalColor = petalColors[Math.floor(Math.random() * 3)];

            // 꽃잎을 생성합니다.
            var geomPetal = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1);
            var matPetal = new THREE.MeshBasicMaterial({ color: petalColor });
            geomPetal.vertices[5].y -= 4;
            geomPetal.vertices[4].y -= 4;
            geomPetal.vertices[7].y += 4;
            geomPetal.vertices[6].y += 4;
            geomPetal.translate(12.5, 0, 3);

            var petals = [];
            for (var i = 0; i < 4; i++) {
                petals[i] = new THREE.Mesh(geomPetal, matPetal);
                petals[i].rotation.z = i * Math.PI / 2;
                petals[i].castShadow = true;
                petals[i].receiveShadow = true;
            }

            petalCore.add(petals[0], petals[1], petals[2], petals[3]);
            petalCore.position.y = 25;
            petalCore.position.z = 3;
            this.mesh.add(petalCore);
        }

        // 선택할 꽃잎 색상 배열.
        var petalColors = [Colors.red, Colors.yellow, Colors.blue];

        // 건물 객체 정의.
        Building = function() {
            this.mesh = new THREE.Object3D();
            var geom = new THREE.BoxGeometry(1, 1, 1);
            var mat = new THREE.MeshPhongMaterial({
                color: Colors.white,
                shading: THREE.FlatShading,
            });
            var building = new THREE.Mesh(geom, mat);
            building.castShadow = true;
            building.receiveShadow = true;
            this.mesh.add(building);
        }

        // 월드 객체 정의 (이전에는 숲).
        World = function () {
            this.mesh = new THREE.Object3D();

            // 나무, 꽃, 건물의 개수를 설정합니다.
            this.nTrees = 300;
            this.nFlowers = 200;
            this.nBuildings = 100;

            // 나무를 무작위로 생성하고 배치합니다.
            for (var i = 0; i < this.nTrees; i++) {
                var t = new Tree();
                t.mesh.position.x = (Math.random() - 0.5) * 4000;
                t.mesh.position.y = 0;
                t.mesh.position.z = (Math.random() - 0.5) * 4000;
                var s = .3 + Math.random() * .75;
                t.mesh.scale.set(s, s, s);
                this.mesh.add(t.mesh);
            }

            // 꽃을 무작위로 생성하고 배치합니다.
            for (var i = 0; i < this.nFlowers; i++) {
                var f = new Flower();
                f.mesh.position.x = (Math.random() - 0.5) * 4000;
                f.mesh.position.y = 0;
                f.mesh.position.z = (Math.random() - 0.5) * 4000;
                var s = .1 + Math.random() * .3;
                f.mesh.scale.set(s, s, s);
                this.mesh.add(f.mesh);
            }

            // 건물을 무작위로 생성하고 배치합니다.
            for (var i = 0; i < this.nBuildings; i++) {
                var b = new Building();
                var sx = 20 + Math.random() * 30;
                var sy = 150 + Math.random() * 250;
                var sz = 20 + Math.random() * 30;
                b.mesh.scale.set(sx, sy, sz);
                b.mesh.position.x = (Math.random() - 0.5) * 4000;
                b.mesh.position.y = sy/2; // 건물의 바닥을 지면에 배치합니다.
                b.mesh.position.z = (Math.random() - 0.5) * 4000;
                this.mesh.add(b.mesh);
            }
        }

        // 게임 객체 및 컨트롤을 위한 전역 변수.
        var airplane;
        var keys = {}; // 키보드 키 상태를 저장하는 객체.
        var airplaneSpeed = 3; // 기본 속도는 이제 3배 빠릅니다.
        var land;
        var world; // forest에서 world로 변경됨
        var yawAngle = 0; // 좌우 회전 각도.
        var pitchAngle = 0; // 상하 회전 각도.

        // 키보드 입력에 대한 이벤트 리스너.
        document.addEventListener('keydown', handleKeyDown, false);
        document.addEventListener('keyup', handleKeyUp, false);

        // 키가 눌렸을 때 키 상태를 true로 설정합니다.
        function handleKeyDown(event) {
            keys[event.key] = true;
        }

        // 키가 놓였을 때 키 상태를 false로 설정합니다.
        function handleKeyUp(event) {
            keys[event.key] = false;
        }

        // 비행기를 생성하고 씬에 추가합니다.
        function createPlane(callback) {
            airplane = new AirPlane(function() {
                airplane.mesh.scale.set(0.0125, 0.0125, 0.0125); // 필요에 따라 스케일 조정 (원래의 1/20)
                airplane.mesh.position.y = 100;
                scene.add(airplane.mesh);
                if (callback) callback();
            });
        }

        // 지면을 생성하고 씬에 추가합니다.
        function createLand() {
            land = new Land();
            land.mesh.position.y = 0;
            scene.add(land.mesh);
        }

        // 월드를 생성하고 씬에 추가합니다.
        function createWorld() {
            world = new World();
            world.mesh.position.y = 0;
            scene.add(world.mesh);
        }

        // 사용자 입력에 따라 비행기의 위치와 회전을 업데이트합니다.
        function updatePlane() {
            var pitchSpeed = 0.025; // 민감도를 낮추기 위해 피치 속도를 느리게 합니다.
            var turnSpeed = 0.025; // 민감도를 낮추기 위해 회전 속도를 느리게 합니다.
            var maxPitch = 80 * Math.PI / 180; // 80도 (라디안).

            // 키보드 입력에 따라 피치 및 요 각도를 업데이트합니다.
            if (keys["ArrowDown"]) { // 아래쪽 화살표는 기수를 올립니다.
                pitchAngle = Math.min(maxPitch, pitchAngle + pitchSpeed);
            }
            if (keys["ArrowUp"]) { // 위쪽 화살표는 기수를 내립니다.
                pitchAngle = Math.max(-maxPitch, pitchAngle - pitchSpeed);
            }
            if (keys["ArrowLeft"]) { // 왼쪽 화살표는 왼쪽으로 요합니다.
                yawAngle += turnSpeed;
            }
            if (keys["ArrowRight"]) { // 오른쪽 화살표는 오른쪽으로 요합니다.
                yawAngle -= turnSpeed;
            }

            // 요 및 피치 회전을 위한 쿼터니언을 생성합니다.
            var yawQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawAngle);
            var pitchQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitchAngle);

            // 회전을 결합합니다: 먼저 요를 적용한 다음 피치를 적용합니다.
            // 이렇게 하면 위/아래 피칭이 비행기의 현재 요 방향에 상대적으로 이루어집니다.
            airplane.mesh.quaternion.copy(yawQ).multiply(pitchQ);

            // 스페이스바가 눌렸는지 여부에 따라 현재 속도와 프로펠러 회전을 결정합니다.
            var currentSpeed = airplaneSpeed;
            if (keys[" "]) { // 스페이스바는 키 코드 32이지만, " "가 더 읽기 쉽습니다.
                currentSpeed *= 2;
            }

            // 현재 방향을 따라 비행기를 앞으로 이동시킵니다.
            var forwardVector = new THREE.Vector3(1, 0, 0); // 로컬 전방 방향은 +X.
            forwardVector.applyQuaternion(airplane.mesh.quaternion); // 월드 공간으로 변환.
            airplane.mesh.position.add(forwardVector.multiplyScalar(currentSpeed));
        }

        // 메인 애니메이션 루프.
        function loop() {
            // 비행기 상태를 업데이트합니다.
            updatePlane();

            // 카메라가 비행기를 뒤에서 약간 위에서 따라가도록 설정합니다.
            var relativeCameraOffset = new THREE.Vector3(-800, 800, 0); // 더 먼 거리를 위해 X 조정
            var cameraOffset = relativeCameraOffset.applyMatrix4(airplane.mesh.matrixWorld);

            // 카메라를 새 오프셋 위치로 부드럽게 이동시킵니다.
            camera.position.lerp(cameraOffset, 0.1);
            camera.up.set(0, 1, 0); // 카메라의 위쪽 방향을 월드의 위쪽과 정렬합니다.
            
            // 카메라가 비행기 앞의 지점을 바라보도록 합니다.
            var lookAtTarget = new THREE.Vector3(1, 0, 0);
            lookAtTarget.applyQuaternion(airplane.mesh.quaternion);
            lookAtTarget.multiplyScalar(500);
            lookAtTarget.add(airplane.mesh.position);
            camera.lookAt(lookAtTarget);

            // 카메라 시점에서 씬을 렌더링합니다.
            renderer.render(scene, camera);
            // 다음 애니메이션 프레임을 요청합니다.
            requestAnimationFrame(loop);
        }

        // 초기화 함수.
        function init(event) {
            createScene();
            createLights();
            createPlane(function() {
                createLand();
                createWorld();
                loop(); // 비행기가 로드된 후 애니메이션 루프를 시작합니다.
            });
        }

        // 페이지가 완전히 로드되면 애플리케이션을 시작합니다.
        window.addEventListener('load', init, false);
    </script>
</body>
</html>