<!DOCTYPE html>
<html>
<head>
    <style>
        * {
            margin: 0;
            padding: 0;
        }
        #world {
            position: absolute;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: linear-gradient(#e4e0ba, #f7d9aa);
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.5);
            color: white;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="controls">
        <p><b>조작법</b></p>
        <p>위 화살표: 기수 내리기</p>
        <p>아래 화살표: 기수 올리기</p>
        <p>왼쪽 화살표: 좌회전</p>
        <p>오른쪽 화살표: 우회전</p>
        <p>스페이스바: 부스트</p>
    </div>
    <div id="world"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/86/three.min.js"></script>
    <script>
        // Colors object: Holds color values for materials to keep them consistent and easy to change.
        var Colors = {
            red: 0xf25346,
            yellow: 0xedeb27,
            white: 0xd8d0d1,
            brown: 0x59332e,
            pink: 0xF5986E,
            brownDark: 0x23190f,
            blue: 0x68c3c0,
            green: 0x458248,
            purple: 0x551A8B,
            lightgreen: 0x629265,
        };

        // SCENE, CAMERA, RENDERER, and other global variables for the Three.js world.
        var scene, camera, fieldOfView, aspectRatio, nearPlane, farPlane, HEIGHT, WIDTH, renderer, container;

        // Initializes the Three.js scene, camera, and renderer.
        function createScene() {
            // Get the window's height and width to set up the aspect ratio and renderer size.
            HEIGHT = window.innerHeight;
            WIDTH = window.innerWidth;

            // Create the scene object.
            scene = new THREE.Scene();

            // Add fog to the scene for a sense of depth. The color matches the background.
            scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);

            // Set up the camera's properties.
            aspectRatio = WIDTH / HEIGHT;
            fieldOfView = 60; // Angle of view in degrees.
            nearPlane = 1; // The closest an object can be to the camera to be rendered.
            farPlane = 10000; // The farthest an object can be from the camera to be rendered.
            camera = new THREE.PerspectiveCamera(
                fieldOfView,
                aspectRatio,
                nearPlane,
                farPlane
            );
            
            // Set the camera's initial position.
            camera.position.x = 0;
            camera.position.z = 200;
            camera.position.y = 100;

            // Create the WebGL renderer.
            renderer = new THREE.WebGLRenderer({
                alpha: true, // Allows for a transparent background.
                antialias: true // Smooths out the edges of objects (can be performance-intensive).
            });

            // Set the size of the renderer to match the window size.
            renderer.setSize(WIDTH, HEIGHT);
            // Enable shadow mapping in the renderer.
            renderer.shadowMap.enabled = true;

            // Get the 'world' div from the HTML and append the renderer's canvas element to it.
            container = document.getElementById('world');
            container.appendChild(renderer.domElement);

            // Add an event listener to handle window resizing.
            window.addEventListener('resize', handleWindowResize, false);
        }

        // Handles window resize events to keep the scene proportional.
        function handleWindowResize() {
            HEIGHT = window.innerHeight;
            WIDTH = window.innerWidth;
            renderer.setSize(WIDTH, HEIGHT);
            camera.aspect = WIDTH / HEIGHT;
            camera.updateProjectionMatrix(); // Must be called after changing camera properties.
        }

        // LIGHTS
        var hemisphereLight, shadowLight;

        // Sets up the lights for the scene.
        function createLights() {
            // Hemisphere light provides a soft, ambient light from above and below.
            hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, .9)
            
            // Directional light simulates sunlight, casting parallel rays.
            shadowLight = new THREE.DirectionalLight(0xffffff, .9);
            shadowLight.position.set(150, 350, 350); // Position the light.
            shadowLight.castShadow = true; // Enable this light to cast shadows.

            // Define the area where shadows will be visible.
            shadowLight.shadow.camera.left = -400;
            shadowLight.shadow.camera.right = 400;
            shadowLight.shadow.camera.top = 400;
            shadowLight.shadow.camera.bottom = -400;
            shadowLight.shadow.camera.near = 1;
            shadowLight.shadow.camera.far = 1000;

            // Set the resolution of the shadow map.
            shadowLight.shadow.mapSize.width = 2048;
            shadowLight.shadow.mapSize.height = 2048;

            // Add the lights to the scene.
            scene.add(hemisphereLight);
            scene.add(shadowLight);
        }

        // AirPlane object definition.
        var AirPlane = function () {
            // The 'mesh' property will hold all the parts of the airplane.
            this.mesh = new THREE.Object3D();

            // Create the main body (cockpit) of the plane.
            var geomCockpit = new THREE.BoxGeometry(80, 50, 50, 1, 1, 1);
            var matCockpit = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
            // Deform the cockpit geometry to make it more airplane-like.
            geomCockpit.vertices[4].y -= 10;
            geomCockpit.vertices[4].z += 20;
            geomCockpit.vertices[5].y -= 10;
            geomCockpit.vertices[5].z -= 20;
            geomCockpit.vertices[6].y += 30;
            geomCockpit.vertices[6].z += 20;
            geomCockpit.vertices[7].y += 30;
            geomCockpit.vertices[7].z -= 20;
            var cockpit = new THREE.Mesh(geomCockpit, matCockpit);
            cockpit.castShadow = true;
            cockpit.receiveShadow = true;
            this.mesh.add(cockpit);

            // Create the engine.
            var geomEngine = new THREE.BoxGeometry(20, 50, 50, 1, 1, 1);
            var matEngine = new THREE.MeshPhongMaterial({ color: Colors.white, shading: THREE.FlatShading });
            var engine = new THREE.Mesh(geomEngine, matEngine);
            engine.position.x = 40;
            engine.castShadow = true;
            engine.receiveShadow = true;
            this.mesh.add(engine);

            // Create the tail.
            var geomTailPlane = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1);
            var matTailPlane = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
            var tailPlane = new THREE.Mesh(geomTailPlane, matTailPlane);
            tailPlane.position.set(-35, 25, 0);
            tailPlane.castShadow = true;
            tailPlane.receiveShadow = true;
            this.mesh.add(tailPlane);

            // Create the wings.
            var geomSideWing = new THREE.BoxGeometry(40, 4, 150, 1, 1, 1);
            var matSideWing = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
            var sideWingTop = new THREE.Mesh(geomSideWing, matSideWing);
            var sideWingBottom = new THREE.Mesh(geomSideWing, matSideWing);
            sideWingTop.castShadow = true;
            sideWingTop.receiveShadow = true;
            sideWingBottom.castShadow = true;
            sideWingBottom.receiveShadow = true;
            sideWingTop.position.set(20, 12, 0);
            sideWingBottom.position.set(20, -3, 0);
            this.mesh.add(sideWingTop);
            this.mesh.add(sideWingBottom);

            // Create the windshield.
            var geomWindshield = new THREE.BoxGeometry(3, 15, 20, 1, 1, 1);
            var matWindshield = new THREE.MeshPhongMaterial({ color: Colors.white, transparent: true, opacity: .3, shading: THREE.FlatShading });;
            var windshield = new THREE.Mesh(geomWindshield, matWindshield);
            windshield.position.set(5, 27, 0);
            windshield.castShadow = true;
            windshield.receiveShadow = true;
            this.mesh.add(windshield);

            // Create the propeller.
            var geomPropeller = new THREE.BoxGeometry(20, 10, 10, 1, 1, 1);
            geomPropeller.vertices[4].y -= 5;
            geomPropeller.vertices[4].z += 5;
            geomPropeller.vertices[5].y -= 5;
            geomPropeller.vertices[5].z -= 5;
            geomPropeller.vertices[6].y += 5;
            geomPropeller.vertices[6].z += 5;
            geomPropeller.vertices[7].y += 5;
            geomPropeller.vertices[7].z -= 5;
            var matPropeller = new THREE.MeshPhongMaterial({ color: Colors.brown, shading: THREE.FlatShading });
            this.propeller = new THREE.Mesh(geomPropeller, matPropeller);
            this.propeller.castShadow = true;
            this.propeller.receiveShadow = true;

            // Create the propeller blades.
            var geomBlade1 = new THREE.BoxGeometry(1, 100, 10, 1, 1, 1);
            var geomBlade2 = new THREE.BoxGeometry(1, 10, 100, 1, 1, 1);
            var matBlade = new THREE.MeshPhongMaterial({ color: Colors.brownDark, shading: THREE.FlatShading });
            var blade1 = new THREE.Mesh(geomBlade1, matBlade);
            blade1.position.set(8, 0, 0);
            blade1.castShadow = true;
            blade1.receiveShadow = true;
            var blade2 = new THREE.Mesh(geomBlade2, matBlade);
            blade2.position.set(8, 0, 0);
            blade2.castShadow = true;
            blade2.receiveShadow = true;
            this.propeller.add(blade1, blade2);
            this.propeller.position.set(50, 0, 0);
            this.mesh.add(this.propeller);

            // Create the landing gear.
            var wheelProtecGeom = new THREE.BoxGeometry(30, 15, 10, 1, 1, 1);
            var wheelProtecMat = new THREE.MeshPhongMaterial({ color: Colors.white, shading: THREE.FlatShading });
            var wheelProtecR = new THREE.Mesh(wheelProtecGeom, wheelProtecMat);
            wheelProtecR.position.set(25, -20, 25);
            this.mesh.add(wheelProtecR);

            var wheelTireGeom = new THREE.BoxGeometry(24, 24, 4);
            var wheelTireMat = new THREE.MeshPhongMaterial({ color: Colors.brownDark, shading: THREE.FlatShading });
            var wheelTireR = new THREE.Mesh(wheelTireGeom, wheelTireMat);
            wheelTireR.position.set(25, -28, 25);

            var wheelAxisGeom = new THREE.BoxGeometry(10, 10, 6);
            var wheelAxisMat = new THREE.MeshPhongMaterial({ color: Colors.brown, shading: THREE.FlatShading });
            var wheelAxis = new THREE.Mesh(wheelAxisGeom, wheelAxisMat);
            wheelTireR.add(wheelAxis);
            this.mesh.add(wheelTireR);

            var wheelProtecL = wheelProtecR.clone();
            wheelProtecL.position.z = -wheelProtecR.position.z;
            this.mesh.add(wheelProtecL);

            var wheelTireL = wheelTireR.clone();
            wheelTireL.position.z = -wheelTireR.position.z;
            this.mesh.add(wheelTireL);

            var wheelTireB = wheelTireR.clone();
            wheelTireB.scale.set(.5, .5, .5);
            wheelTireB.position.set(-35, -5, 0);
            this.mesh.add(wheelTireB);

            var suspensionGeom = new THREE.BoxGeometry(4, 20, 4);
            suspensionGeom.applyMatrix(new THREE.Matrix4().makeTranslation(0, 10, 0))
            var suspensionMat = new THREE.MeshPhongMaterial({ color: Colors.red, shading: THREE.FlatShading });
            var suspension = new THREE.Mesh(suspensionGeom, suspensionMat);
            suspension.position.set(-35, -5, 0);
            suspension.rotation.z = -.3;
            this.mesh.add(suspension);
        };

        // Land object definition.
        Land = function () {
            var geom = new THREE.PlaneGeometry(20000, 20000, 1, 1);
            geom.rotateX(-Math.PI / 2); // Rotate the plane to be horizontal.
            var mat = new THREE.MeshPhongMaterial({
                color: Colors.lightgreen,
                shading: THREE.FlatShading,
            });
            this.mesh = new THREE.Mesh(geom, mat);
            this.mesh.receiveShadow = true; // The ground should receive shadows.
        }

        // Tree object definition.
        Tree = function () {
            this.mesh = new THREE.Object3D();

            var matTreeLeaves = new THREE.MeshPhongMaterial({ color: Colors.green, shading: THREE.FlatShading });

            // Create the trunk.
            var geonTreeBase = new THREE.BoxGeometry(10, 20, 10);
            var matTreeBase = new THREE.MeshBasicMaterial({ color: Colors.brown });
            var treeBase = new THREE.Mesh(geonTreeBase, matTreeBase);
            treeBase.castShadow = true;
            treeBase.receiveShadow = true;
            this.mesh.add(treeBase);

            // Create the leaves using cylinders.
            var geomTreeLeaves1 = new THREE.CylinderGeometry(1, 12 * 3, 12 * 3, 4);
            var treeLeaves1 = new THREE.Mesh(geomTreeLeaves1, matTreeLeaves);
            treeLeaves1.castShadow = true;
            treeLeaves1.receiveShadow = true;
            treeLeaves1.position.y = 20
            this.mesh.add(treeLeaves1);

            var geomTreeLeaves2 = new THREE.CylinderGeometry(1, 9 * 3, 9 * 3, 4);
            var treeLeaves2 = new THREE.Mesh(geomTreeLeaves2, matTreeLeaves);
            treeLeaves2.castShadow = true;
            treeLeaves2.position.y = 40;
            treeLeaves2.receiveShadow = true;
            this.mesh.add(treeLeaves2);

            var geomTreeLeaves3 = new THREE.CylinderGeometry(1, 6 * 3, 6 * 3, 4);
            var treeLeaves3 = new THREE.Mesh(geomTreeLeaves3, matTreeLeaves);
            treeLeaves3.castShadow = true;
            treeLeaves3.position.y = 55;
            treeLeaves3.receiveShadow = true;
            this.mesh.add(treeLeaves3);
        }

        // Flower object definition.
        Flower = function () {
            this.mesh = new THREE.Object3D();

            // Create the stem.
            var geomStem = new THREE.BoxGeometry(5, 50, 5, 1, 1, 1);
            var matStem = new THREE.MeshPhongMaterial({ color: Colors.green, shading: THREE.FlatShading });
            var stem = new THREE.Mesh(geomStem, matStem);
            stem.castShadow = false;
            stem.receiveShadow = true;
            this.mesh.add(stem);

            // Create the center of the flower.
            var geomPetalCore = new THREE.BoxGeometry(10, 10, 10, 1, 1, 1);
            var matPetalCore = new THREE.MeshPhongMaterial({ color: Colors.yellow, shading: THREE.FlatShading });
            petalCore = new THREE.Mesh(geomPetalCore, matPetalCore);
            petalCore.castShadow = false;
            petalCore.receiveShadow = true;

            // Choose a random color for the petals.
            var petalColor = petalColors[Math.floor(Math.random() * 3)];

            // Create the petals.
            var geomPetal = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1);
            var matPetal = new THREE.MeshBasicMaterial({ color: petalColor });
            geomPetal.vertices[5].y -= 4;
            geomPetal.vertices[4].y -= 4;
            geomPetal.vertices[7].y += 4;
            geomPetal.vertices[6].y += 4;
            geomPetal.translate(12.5, 0, 3);

            var petals = [];
            for (var i = 0; i < 4; i++) {
                petals[i] = new THREE.Mesh(geomPetal, matPetal);
                petals[i].rotation.z = i * Math.PI / 2;
                petals[i].castShadow = true;
                petals[i].receiveShadow = true;
            }

            petalCore.add(petals[0], petals[1], petals[2], petals[3]);
            petalCore.position.y = 25;
            petalCore.position.z = 3;
            this.mesh.add(petalCore);
        }

        // Array of petal colors to be chosen from.
        var petalColors = [Colors.red, Colors.yellow, Colors.blue];

        Building = function() {
            this.mesh = new THREE.Object3D();
            var geom = new THREE.BoxGeometry(1, 1, 1);
            var mat = new THREE.MeshPhongMaterial({
                color: Colors.white,
                shading: THREE.FlatShading,
            });
            var building = new THREE.Mesh(geom, mat);
            building.castShadow = true;
            building.receiveShadow = true;
            this.mesh.add(building);
        }

        // World object definition (previously Forest).
        World = function () {
            this.mesh = new THREE.Object3D();

            // Set the number of trees, flowers, and buildings.
            this.nTrees = 300;
            this.nFlowers = 200;
            this.nBuildings = 100;

            // Create and position the trees randomly.
            for (var i = 0; i < this.nTrees; i++) {
                var t = new Tree();
                t.mesh.position.x = (Math.random() - 0.5) * 4000;
                t.mesh.position.y = 0;
                t.mesh.position.z = (Math.random() - 0.5) * 4000;
                var s = .3 + Math.random() * .75;
                t.mesh.scale.set(s, s, s);
                this.mesh.add(t.mesh);
            }

            // Create and position the flowers randomly.
            for (var i = 0; i < this.nFlowers; i++) {
                var f = new Flower();
                f.mesh.position.x = (Math.random() - 0.5) * 4000;
                f.mesh.position.y = 0;
                f.mesh.position.z = (Math.random() - 0.5) * 4000;
                var s = .1 + Math.random() * .3;
                f.mesh.scale.set(s, s, s);
                this.mesh.add(f.mesh);
            }

            // Create and position the buildings randomly.
            for (var i = 0; i < this.nBuildings; i++) {
                var b = new Building();
                var sx = 20 + Math.random() * 30;
                var sy = 150 + Math.random() * 250;
                var sz = 20 + Math.random() * 30;
                b.mesh.scale.set(sx, sy, sz);
                b.mesh.position.x = (Math.random() - 0.5) * 4000;
                b.mesh.position.y = sy/2; // Position the base of the building on the ground.
                b.mesh.position.z = (Math.random() - 0.5) * 4000;
                this.mesh.add(b.mesh);
            }
        }

        // Global variables for game objects and controls.
        var airplane;
        var keys = {}; // Object to store the state of keyboard keys.
        var airplaneSpeed = 3; // Base speed is now 3x faster.
        var land;
        var world; // Changed from forest to world
        var yawAngle = 0; // Left-right rotation angle.
        var pitchAngle = 0; // Up-down rotation angle.

        // Event listeners for keyboard input.
        document.addEventListener('keydown', handleKeyDown, false);
        document.addEventListener('keyup', handleKeyUp, false);

        // Sets the key state to true when a key is pressed.
        function handleKeyDown(event) {
            keys[event.key] = true;
        }

        // Sets the key state to false when a key is released.
        function handleKeyUp(event) {
            keys[event.key] = false;
        }

        // Creates the airplane and adds it to the scene.
        function createPlane() {
            airplane = new AirPlane();
            airplane.mesh.scale.set(.25, .25, .25);
            airplane.mesh.position.y = 100;
            scene.add(airplane.mesh);
        }

        // Creates the land and adds it to the scene.
        function createLand() {
            land = new Land();
            land.mesh.position.y = 0;
            scene.add(land.mesh);
        }

        // Creates the world and adds it to the scene.
        function createWorld() {
            world = new World();
            world.mesh.position.y = 0;
            scene.add(world.mesh);
        }

        // Updates the airplane's position and rotation based on user input.
        function updatePlane() {
            var pitchSpeed = 0.025; // Slower pitch speed for less sensitivity.
            var turnSpeed = 0.025; // Slower turn speed for less sensitivity.
            var maxPitch = 80 * Math.PI / 180; // 80 degrees in radians.

            // Update pitch and yaw angles based on keyboard input.
            if (keys["ArrowDown"]) { // Down arrow for nose up.
                pitchAngle = Math.min(maxPitch, pitchAngle + pitchSpeed);
            }
            if (keys["ArrowUp"]) { // Up arrow for nose down.
                pitchAngle = Math.max(-maxPitch, pitchAngle - pitchSpeed);
            }
            if (keys["ArrowLeft"]) { // Left arrow for yaw left.
                yawAngle += turnSpeed;
            }
            if (keys["ArrowRight"]) { // Right arrow for yaw right.
                yawAngle -= turnSpeed;
            }

            // Create quaternions for yaw and pitch rotations.
            var yawQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawAngle);
            var pitchQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitchAngle);

            // Combine the rotations: first apply yaw, then pitch.
            // This ensures that pitching up/down is relative to the plane's current yaw direction.
            airplane.mesh.quaternion.copy(yawQ).multiply(pitchQ);

            // Determine the current speed and propeller rotation based on whether the spacebar is pressed.
            var currentSpeed = airplaneSpeed;
            var propellerRotationSpeed = 0.3;
            if (keys[" "]) { // Spacebar is key code 32, but " " is more readable.
                currentSpeed *= 2;
                propellerRotationSpeed *= 4; // Propeller speed is now 4x faster during boost.
            }

            // Move the plane forward along its current direction.
            var forwardVector = new THREE.Vector3(1, 0, 0); // Local forward direction is +X.
            forwardVector.applyQuaternion(airplane.mesh.quaternion); // Transform to world space.
            airplane.mesh.position.add(forwardVector.multiplyScalar(currentSpeed));

            // Animate the propeller.
            airplane.propeller.rotation.x += propellerRotationSpeed;
        }

        // The main animation loop.
        function loop() {
            // Update the plane's state.
            updatePlane();

            // Set the camera to follow the airplane from behind and slightly above.
            var relativeCameraOffset = new THREE.Vector3(-250, 155, 0); // Adjusted Y for a 10-degree downward view
            var cameraOffset = relativeCameraOffset.applyMatrix4(airplane.mesh.matrixWorld);

            // Smoothly move the camera to the new offset position.
            camera.position.lerp(cameraOffset, 0.1);
            camera.up.set(0, 1, 0); // Keep the camera's up direction aligned with the world's up.
            
            // Make the camera look at a point in front of the airplane.
            var lookAtTarget = new THREE.Vector3(1, 0, 0);
            lookAtTarget.applyQuaternion(airplane.mesh.quaternion);
            lookAtTarget.multiplyScalar(500);
            lookAtTarget.add(airplane.mesh.position);
            camera.lookAt(lookAtTarget);

            // Render the scene from the camera's perspective.
            renderer.render(scene, camera);
            // Request the next frame of the animation.
            requestAnimationFrame(loop);
        }

        // Initialization function.
        function init(event) {
            createScene();
            createLights();
            createPlane();
            createLand();
            createWorld();
            loop(); // Start the animation loop.
        }

        // Start the application once the page has fully loaded.
        window.addEventListener('load', init, false);
    </script>
</body>
</html>