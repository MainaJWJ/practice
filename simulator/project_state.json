{
  "files": {
    "airplane.html": "<!DOCTYPE html>\n<html lang=\"ko\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>비행 시뮬레이터</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <aside id=\"controls\">\n        <p><b>조작법</b></p>\n        <p>위 화살표: 기수 내리기</p>\n        <p>아래 화살표: 기수 올리기</p>\n        <p>왼쪽 화살표: 좌회전</p>\n        <p>오른쪽 화살표: 우회전</p>\n        <p>스페이스바: 부스트</p>\n        <p><b>기체 변경</b></p>\n        <button onclick=\"changeAirplane('b-747')\">B-747</button>\n        <button onclick=\"changeAirplane('b-757')\">B-757</button>\n        <button onclick=\"changeAirplane('cessna')\">Cessna</button>\n        <p><b>지형 변경</b></p>\n        <button onclick=\"changeWorld('default')\">기본</button>\n        <button onclick=\"changeWorld('desert')\">사막</button>\n    </aside>\n    <main id=\"world\"></main>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/86/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.86.0/examples/js/loaders/OBJLoader.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.86.0/examples/js/loaders/MTLLoader.js\"></script>\n    <script src=\"main.js\"></script>\n</body>\n</html>",
    "style.css": "* {\n    margin: 0;\n    padding: 0;\n}\n#world {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: linear-gradient(#e4e0ba, #f7d9aa);\n}\n#controls {\n    position: absolute;\n    top: 10px;\n    right: 10px;\n    padding: 10px;\n    background-color: rgba(0,0,0,0.5);\n    color: white;\n    border-radius: 5px;\n    font-family: monospace;\n    z-index: 1000;\n}",
    "main.js": "// 색상 객체: 재료의 색상 값을 일관성 있게 유지하고 쉽게 변경할 수 있도록 합니다.\nvar Colors = {\n    red: 0xf25346,\n    yellow: 0xedeb27,\n    white: 0xd8d0d1,\n    brown: 0x59332e,\n    pink: 0xF5986E,\n    brownDark: 0x23190f,\n    blue: 0x68c3c0,\n    green: 0x458248,\n    purple: 0x551A8B,\n    lightgreen: 0x629265,\n};\n\n// SCENE, CAMERA, RENDERER 및 Three.js 월드의 기타 전역 변수.\nvar scene, camera, fieldOfView, aspectRatio, nearPlane, farPlane, HEIGHT, WIDTH, renderer, container;\n\n// Three.js 씬, 카메라, 렌더러를 초기화합니다.\nfunction createScene() {\n    // 창의 높이와 너비를 가져와 종횡비와 렌더러 크기를 설정합니다.\n    HEIGHT = window.innerHeight;\n    WIDTH = window.innerWidth;\n\n    // 씬 객체를 생성합니다.\n    scene = new THREE.Scene();\n\n    // 깊이감을 위해 씬에 안개를 추가합니다. 색상은 배경과 일치합니다.\n    scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);\n\n    // 카메라의 속성을 설정합니다.\n    aspectRatio = WIDTH / HEIGHT;\n    fieldOfView = 60; // 시야각 (도).\n    nearPlane = 1; // 렌더링될 카메라에 가장 가까운 객체.\n    farPlane = 10000; // 렌더링될 카메라에서 가장 먼 객체.\n    camera = new THREE.PerspectiveCamera(\n        fieldOfView,\n        aspectRatio,\n        nearPlane,\n        farPlane\n    );\n    \n    // 카메라의 초기 위치를 설정합니다.\n    camera.position.x = 0;\n    camera.position.z = 200;\n    camera.position.y = 100;\n\n    // WebGL 렌더러를 생성합니다.\n    renderer = new THREE.WebGLRenderer({\n        alpha: true, // 투명한 배경을 허용합니다.\n        antialias: true // 객체의 가장자리를 부드럽게 합니다 (성능 집약적일 수 있음).\n    });\n\n    // 렌더러의 크기를 창 크기와 일치하도록 설정합니다.\n    renderer.setSize(WIDTH, HEIGHT);\n    // 렌더러에서 그림자 매핑을 활성화합니다.\n    renderer.shadowMap.enabled = true;\n\n    // HTML에서 'world' div를 가져와 렌더러의 캔버스 요소를 추가합니다.\n    container = document.getElementById('world');\n    container.appendChild(renderer.domElement);\n\n    // 창 크기 조정 이벤트를 처리하기 위한 이벤트 리스너를 추가합니다.\n    window.addEventListener('resize', handleWindowResize, false);\n}\n\n// 씬의 비율을 유지하기 위해 창 크기 조정 이벤트를 처리합니다.\nfunction handleWindowResize() {\n    HEIGHT = window.innerHeight;\n    WIDTH = window.innerWidth;\n    renderer.setSize(WIDTH, HEIGHT);\n    camera.aspect = WIDTH / HEIGHT;\n    camera.updateProjectionMatrix(); // 카메라 속성 변경 후 호출해야 합니다.\n}\n\n// 조명\nvar hemisphereLight, shadowLight;\n\n// 씬의 조명을 설정합니다.\nfunction createLights() {\n    // 반구형 조명은 위아래에서 부드러운 주변 조명을 제공합니다.\n    hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, .9)\n    \n    // 방향성 조명은 평행 광선을 투사하여 햇빛을 시뮬레이션합니다.\n    shadowLight = new THREE.DirectionalLight(0xffffff, .9);\n    shadowLight.position.set(150, 350, 350); // 조명 위치 설정.\n    shadowLight.castShadow = true; // 이 조명이 그림자를 드리우도록 활성화합니다.\n\n    // 그림자가 보이는 영역을 정의합니다.\n    shadowLight.shadow.camera.left = -400;\n    shadowLight.shadow.camera.right = 400;\n    shadowLight.shadow.camera.top = 400;\n    shadowLight.shadow.camera.bottom = -400;\n    shadowLight.shadow.camera.near = 1;\n    shadowLight.shadow.camera.far = 1000;\n\n    // 그림자 맵의 해상도를 설정합니다.\n    shadowLight.shadow.mapSize.width = 2048;\n    shadowLight.shadow.mapSize.height = 2048;\n\n    // 씬에 조명을 추가합니다.\n    scene.add(hemisphereLight);\n    scene.add(shadowLight);\n}\n\n// 비행기 객체 정의.\nvar airplaneConfigs = {\n    'b-747': { configPath: 'b-747/config.json' },\n    'b-757': { configPath: 'b-757/config.json' },\n    'cessna': { configPath: 'cessna/config.json' }\n};\n\nvar AirPlane = function (modelName, callback) {\n    this.mesh = new THREE.Object3D();\n    var self = this; // 'this' 컨텍스트를 유지합니다.\n\n    var configPath = airplaneConfigs[modelName].configPath;\n    fetch(configPath)\n        .then(response => response.json())\n        .then(config => {\n            self.config = config; // 나중에 사용하기 위해 config를 저장합니다.\n\n            var mtlLoader = new THREE.MTLLoader();\n            mtlLoader.setPath(modelName + '/');\n            mtlLoader.load(config.model.mtl, function (materials) {\n                materials.preload();\n                var objLoader = new THREE.OBJLoader();\n                objLoader.setMaterials(materials);\n                objLoader.setPath(modelName + '/');\n                objLoader.load(config.model.obj, function (object) {\n                    object.traverse(function (child) {\n                        if (child instanceof THREE.Mesh) {\n                            child.castShadow = true;\n                            child.receiveShadow = true;\n                        }\n                    });\n                    object.rotation.x = config.model.rotation.x;\n                    object.rotation.y = config.model.rotation.y;\n                    object.rotation.z = config.model.rotation.z;\n                    self.mesh.add(object);\n                    if (callback) callback();\n                });\n            });\n        });\n};\n\n// 지면 객체 정의.\nLand = function (config) {\n    var geom = new THREE.PlaneGeometry(20000, 20000, 1, 1);\n    geom.rotateX(-Math.PI / 2); // 평면을 수평으로 회전합니다.\n    var mat = new THREE.MeshPhongMaterial({\n        color: parseInt(config.landColor, 16),\n        shading: THREE.FlatShading,\n    });\n    this.mesh = new THREE.Mesh(geom, mat);\n    this.mesh.receiveShadow = true; // 지면은 그림자를 받아야 합니다.\n}\n\nvar worldObjectBlueprints = {};\n\n// 월드 객체 정의 (이전에는 숲).\nWorld = function (worldName, config) {\n    this.mesh = new THREE.Object3D();\n    var blueprints = worldObjectBlueprints[worldName];\n\n    if (config.objects && blueprints) {\n        config.objects.forEach(objConfig => {\n            var blueprint = blueprints[objConfig.type];\n            if (blueprint) {\n                for (let i = 0; i < objConfig.count; i++) {\n                    let obj = new blueprint();\n                    obj.mesh.position.x = (Math.random() - 0.5) * 4000;\n                    obj.mesh.position.y = 0;\n                    obj.mesh.position.z = (Math.random() - 0.5) * 4000;\n\n                    if (objConfig.type === 'building') {\n                        const sx = 20 + Math.random() * 30;\n                        const sy = 150 + Math.random() * 250;\n                        const sz = 20 + Math.random() * 30;\n                        obj.mesh.scale.set(sx, sy, sz);\n                        obj.mesh.position.y = sy / 2;\n                    } else {\n                        const s = (objConfig.type === 'tree') ? (.3 + Math.random() * .75) : (.1 + Math.random() * .3);\n                        obj.mesh.scale.set(s, s, s);\n                    }\n                    this.mesh.add(obj.mesh);\n                }\n            }\n        });\n    }\n}\n\n// 게임 객체 및 컨트롤을 위한 전역 변수.\nvar airplane;\nvar keys = {}; // 키보드 키 상태를 저장하는 객체.\nvar airplaneSpeed = 3; // 기본 속도는 이제 3배 빠릅니다.\nvar land;\nvar world; // forest에서 world로 변경됨\nvar yawAngle = 0; // 좌우 회전 각도.\nvar pitchAngle = 0; // 상하 회전 각도.\n\n// 키보드 입력에 대한 이벤트 리스너.\ndocument.addEventListener('keydown', handleKeyDown, false);\ndocument.addEventListener('keyup', handleKeyUp, false);\n\n// 키가 눌렸을 때 키 상태를 true로 설정합니다.\nfunction handleKeyDown(event) {\n    keys[event.key] = true;\n\n    if (event.key === '1') {\n        changeAirplane('b-747');\n    }\n    if (event.key === '2') {\n        changeAirplane('b-757');\n    }\n}\n\n// 키가 놓였을 때 키 상태를 false로 설정합니다.\nfunction handleKeyUp(event) {\n    keys[event.key] = false;\n}\n\n// 비행기를 생성하고 씬에 추가합니다.\nfunction createPlane(modelName, callback) {\n    airplane = new AirPlane(modelName, function() {\n        var scale = airplane.config.model.scale || 0.0125; // config에 없으면 기본값 사용\n        airplane.mesh.scale.set(scale, scale, scale); \n        airplane.mesh.position.y = 100;\n        scene.add(airplane.mesh);\n        if (callback) callback();\n    });\n}\n\n// 지면을 생성하고 씬에 추가합니다.\nfunction createLand(config) {\n    land = new Land(config);\n    land.mesh.position.y = 0;\n    scene.add(land.mesh);\n}\n\n// 월드를 생성하고 씬에 추가합니다.\nfunction createWorld(worldName, config) {\n    world = new World(worldName, config);\n    world.mesh.position.y = 0;\n    scene.add(world.mesh);\n}\n\nfunction changeWorld(worldName) {\n    var worldPath = 'worlds/' + worldName + '/';\n    var configPath = worldPath + 'config.json';\n    var scriptPath = worldPath + 'main.js';\n\n    // 스크립트 로더\n    var script = document.createElement('script');\n    script.src = scriptPath;\n    script.onload = function() {\n        fetch(configPath)\n            .then(response => response.json())\n            .then(config => {\n                if (land && land.mesh) {\n                    scene.remove(land.mesh);\n                }\n                if (world && world.mesh) {\n                    scene.remove(world.mesh);\n                }\n                scene.fog = new THREE.Fog(parseInt(config.fogColor, 16), 100, 950);\n                createLand(config);\n                createWorld(worldName, config);\n            });\n    };\n    document.head.appendChild(script);\n}\n\n// 사용자 입력에 따라 비행기의 위치와 회전을 업데이트합니다.\nfunction updatePlane() {\n    if (!airplane || !airplane.config) return; // 비행기 또는 설정이 로드되지 않았으면 아무것도 하지 않습니다.\n\n    var pitchSpeed = airplane.config.performance.turnSensitivity;\n    var turnSpeed = airplane.config.performance.turnSensitivity;\n    var maxPitch = 80 * Math.PI / 180; // 80도 (라디안).\n\n    // 키보드 입력에 따라 피치 및 요 각도를 업데이트합니다.\n    if (keys[\"ArrowDown\"]) { // 아래쪽 화살표는 기수를 올립니다.\n        pitchAngle = Math.min(maxPitch, pitchAngle + pitchSpeed);\n    }\n    if (keys[\"ArrowUp\"]) { // 위쪽 화살표는 기수를 내립니다.\n        pitchAngle = Math.max(-maxPitch, pitchAngle - pitchSpeed);\n    }\n    if (keys[\"ArrowLeft\"]) { // 왼쪽 화살표는 왼쪽으로 요합니다.\n        yawAngle += turnSpeed;\n    }\n    if (keys[\"ArrowRight\"]) { // 오른쪽 화살표는 오른쪽으로 요합니다.\n        yawAngle -= turnSpeed;\n    }\n\n    // 요 및 피치 회전을 위한 쿼터니언을 생성합니다.\n    var yawQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawAngle);\n    var pitchQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitchAngle);\n\n    // 회전을 결합합니다: 먼저 요를 적용한 다음 피치를 적용합니다.\n    // 이렇게 하면 위/아래 피칭이 비행기의 현재 요 방향에 상대적으로 이루어집니다.\n    airplane.mesh.quaternion.copy(yawQ).multiply(pitchQ);\n\n    // 스페이스바가 눌렸는지 여부에 따라 현재 속도와 프로펠러 회전을 결정합니다.\n    var currentSpeed = airplane.config.performance.speed;\n    if (keys[\" \"]) { // 스페이스바는 키 코드 32이지만, \" \"가 더 읽기 쉽습니다.\n        currentSpeed *= airplane.config.performance.boostMultiplier;\n    }\n\n    // 현재 방향을 따라 비행기를 앞으로 이동시킵니다.\n    var forwardVector = new THREE.Vector3(1, 0, 0); // 로컬 전방 방향은 +X.\n    forwardVector.applyQuaternion(airplane.mesh.quaternion); // 월드 공간으로 변환.\n    airplane.mesh.position.add(forwardVector.multiplyScalar(currentSpeed));\n}\n\n// 메인 애니메이션 루프.\nfunction loop() {\n    // 비행기 상태를 업데이트합니다.\n    updatePlane();\n\n    // 카메라가 비행기를 뒤에서 약간 위에서 따라가도록 설정합니다.\n    var relativeCameraOffset = new THREE.Vector3(-800, 800, 0); // 더 먼 거리를 위해 X 조정\n    var cameraOffset = relativeCameraOffset.applyMatrix4(airplane.mesh.matrixWorld);\n\n    // 카메라를 새 오프셋 위치로 부드럽게 이동시킵니다.\n    camera.position.lerp(cameraOffset, 0.1);\n    camera.up.set(0, 1, 0); // 카메라의 위쪽 방향을 월드의 위쪽과 정렬합니다.\n    \n    // 카메라가 비행기 앞의 지점을 바라보도록 합니다.\n    var lookAtTarget = new THREE.Vector3(1, 0, 0);\n    lookAtTarget.applyQuaternion(airplane.mesh.quaternion);\n    lookAtTarget.multiplyScalar(500);\n    lookAtTarget.add(airplane.mesh.position);\n    camera.lookAt(lookAtTarget);\n\n    // 카메라 시점에서 씬을 렌더링합니다.\n    renderer.render(scene, camera);\n    // 다음 애니메이션 프레임을 요청합니다.\n    requestAnimationFrame(loop);\n}\n\nfunction changeAirplane(modelName) {\n    if (airplane && airplane.mesh) {\n        scene.remove(airplane.mesh);\n    }\n    pitchAngle = 0;\n    yawAngle = 0;\n    createPlane(modelName, function() {\n        // 비행기가 로드된 후 필요한 경우 추가 작업을 수행합니다.\n    });\n}\n\n// 초기화 함수.\nfunction init(event) {\n    createScene();\n    createLights();\n    createPlane('b-747', function() {\n        changeWorld('default');\n        loop(); // 비행기가 로드된 후 애니메이션 루프를 시작합니다.\n    });\n}\n\n// 페이지가 완전히 로드되면 애플리케이션을 시작합니다.\nwindow.addEventListener('load', init, false);",
    "b-747\\config.json": "{\n  \"model\": {\n    \"mtl\": \"11803_Airplane_v1_l1.mtl\",\n    \"obj\": \"11803_Airplane_v1_l1.obj\",\n    \"rotation\": {\n      \"x\": 1.5707963267948966,\n      \"y\": 3.141592653589793,\n      \"z\": 3.141592653589793\n    },\n    \"scale\": 0.0125\n  },\n  \"performance\": {\n    \"speed\": 3,\n    \"turnSensitivity\": 0.025,\n    \"boostMultiplier\": 2\n  },\n  \"combat\": {\n    \"attack\": 10,\n    \"defense\": 10,\n    \"health\": 100,\n    \"ammo\": {\n      \"weapon1\": 100,\n      \"weapon2\": 50,\n      \"weapon3\": 10\n    }\n  },\n  \"future_expansion\": {}\n}",
    "b-757\\config.json": "{\n  \"model\": {\n    \"mtl\": \"11803_Airplane_v1_l1.mtl\",\n    \"obj\": \"11803_Airplane_v1_l1.obj\",\n    \"rotation\": {\n      \"x\": 1.5707963267948966,\n      \"y\": 3.141592653589793,\n      \"z\": 3.141592653589793\n    },\n    \"scale\": 0.0125\n  },\n  \"performance\": {\n    \"speed\": 6,\n    \"turnSensitivity\": 0.05,\n    \"boostMultiplier\": 4\n  },\n  \"combat\": {\n    \"attack\": 10,\n    \"defense\": 10,\n    \"health\": 100,\n    \"ammo\": {\n      \"weapon1\": 100,\n      \"weapon2\": 50,\n      \"weapon3\": 10\n    }\n  },\n  \"future_expansion\": {}\n}",
    "cessna\\config.json": "{\n  \"model\": {\n    \"mtl\": \"11804_Airplane_v2_l2.mtl\",\n    \"obj\": \"11804_Airplane_v2_l2.obj\",\n    \"rotation\": {\n      \"x\": 1.5707963267948966,\n      \"y\": 3.141592653589793,\n      \"z\": 0\n    },\n    \"scale\": 0.0125\n  },\n  \"performance\": {\n    \"speed\": 3,\n    \"turnSensitivity\": 0.025,\n    \"boostMultiplier\": 2\n  },\n  \"combat\": {\n    \"attack\": 10,\n    \"defense\": 10,\n    \"health\": 100,\n    \"ammo\": {\n      \"weapon1\": 100,\n      \"weapon2\": 50,\n      \"weapon3\": 10\n    }\n  },\n  \"future_expansion\": {}\n}",
    "worlds\\default\\config.json": "{\n  \"landColor\": \"0x629265\",\n  \"fogColor\": \"0xf7d9aa\",\n  \"objects\": [\n    { \"type\": \"tree\", \"count\": 300 },\n    { \"type\": \"flower\", \"count\": 200 },\n    { \"type\": \"building\", \"count\": 100 }\n  ]\n}",
    "worlds\\default\\main.js": "var petalColors = [0xf25346, 0xedeb27, 0x68c3c0];\n\nworldObjectBlueprints.default = {\n    'tree': function() {\n        this.mesh = new THREE.Object3D();\n        var matTreeLeaves = new THREE.MeshPhongMaterial({ color: 0x458248, shading: THREE.FlatShading });\n        var geonTreeBase = new THREE.BoxGeometry(10, 20, 10);\n        var matTreeBase = new THREE.MeshBasicMaterial({ color: 0x59332e });\n        var treeBase = new THREE.Mesh(geonTreeBase, matTreeBase);\n        treeBase.castShadow = true;\n        treeBase.receiveShadow = true;\n        this.mesh.add(treeBase);\n        var geomTreeLeaves1 = new THREE.CylinderGeometry(1, 12 * 3, 12 * 3, 4);\n        var treeLeaves1 = new THREE.Mesh(geomTreeLeaves1, matTreeLeaves);\n        treeLeaves1.castShadow = true;\n        treeLeaves1.receiveShadow = true;\n        treeLeaves1.position.y = 20;\n        this.mesh.add(treeLeaves1);\n        var geomTreeLeaves2 = new THREE.CylinderGeometry(1, 9 * 3, 9 * 3, 4);\n        var treeLeaves2 = new THREE.Mesh(geomTreeLeaves2, matTreeLeaves);\n        treeLeaves2.castShadow = true;\n        treeLeaves2.position.y = 40;\n        treeLeaves2.receiveShadow = true;\n        this.mesh.add(treeLeaves2);\n        var geomTreeLeaves3 = new THREE.CylinderGeometry(1, 6 * 3, 6 * 3, 4);\n        var treeLeaves3 = new THREE.Mesh(geomTreeLeaves3, matTreeLeaves);\n        treeLeaves3.castShadow = true;\n        treeLeaves3.position.y = 55;\n        treeLeaves3.receiveShadow = true;\n        this.mesh.add(treeLeaves3);\n    },\n    'flower': function() {\n        this.mesh = new THREE.Object3D();\n        var geomStem = new THREE.BoxGeometry(5, 50, 5, 1, 1, 1);\n        var matStem = new THREE.MeshPhongMaterial({ color: 0x458248, shading: THREE.FlatShading });\n        var stem = new THREE.Mesh(geomStem, matStem);\n        stem.castShadow = false;\n        stem.receiveShadow = true;\n        this.mesh.add(stem);\n        var geomPetalCore = new THREE.BoxGeometry(10, 10, 10, 1, 1, 1);\n        var matPetalCore = new THREE.MeshPhongMaterial({ color: 0xedeb27, shading: THREE.FlatShading });\n        var petalCore = new THREE.Mesh(geomPetalCore, matPetalCore);\n        petalCore.castShadow = false;\n        petalCore.receiveShadow = true;\n        var petalColor = petalColors[Math.floor(Math.random() * 3)];\n        var geomPetal = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1);\n        var matPetal = new THREE.MeshBasicMaterial({ color: petalColor });\n        geomPetal.vertices[5].y -= 4;\n        geomPetal.vertices[4].y -= 4;\n        geomPetal.vertices[7].y += 4;\n        geomPetal.vertices[6].y += 4;\n        geomPetal.translate(12.5, 0, 3);\n        var petals = [];\n        for (var i = 0; i < 4; i++) {\n            petals[i] = new THREE.Mesh(geomPetal, matPetal);\n            petals[i].rotation.z = i * Math.PI / 2;\n            petals[i].castShadow = true;\n            petals[i].receiveShadow = true;\n        }\n        petalCore.add(petals[0], petals[1], petals[2], petals[3]);\n        petalCore.position.y = 25;\n        petalCore.position.z = 3;\n        this.mesh.add(petalCore);\n    },\n    'building': function() {\n        this.mesh = new THREE.Object3D();\n        var geom = new THREE.BoxGeometry(1, 1, 1);\n        var mat = new THREE.MeshPhongMaterial({ color: 0xd8d0d1, shading: THREE.FlatShading });\n        var building = new THREE.Mesh(geom, mat);\n        building.castShadow = true;\n        building.receiveShadow = true;\n        this.mesh.add(building);\n    }\n};\n",
    "worlds\\desert\\config.json": "{\n  \"landColor\": \"0xd2b48c\",\n  \"fogColor\": \"0xf0e68c\",\n  \"objects\": []\n}",
    "worlds\\desert\\main.js": "// 사막 지형을 위한 객체들을 이곳에 추가할 수 있습니다.\nworldObjectBlueprints.desert = {};"
  },
  "structure": [
    "C:\\Users\\정원준\\Desktop\\simulator\\airplane.html",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_body_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_tail_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_v1_l1.mtl",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_v1_l1.obj",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_wing_big_L_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_wing_big_R_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_wing_details_L_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\11803_Airplane_wing_details_R_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-747\\config.json",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_body_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_tail_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_v1_l1.mtl",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_v1_l1.obj",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_wing_big_L_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_wing_big_R_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_wing_details_L_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\11803_Airplane_wing_details_R_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\b-757\\config.json",
    "C:\\Users\\정원준\\Desktop\\simulator\\cessna\\",
    "C:\\Users\\정원준\\Desktop\\simulator\\cessna\\11804_Airplane_diff.jpg",
    "C:\\Users\\정원준\\Desktop\\simulator\\cessna\\11804_Airplane_v2_l2.mtl",
    "C:\\Users\\정원준\\Desktop\\simulator\\cessna\\11804_Airplane_v2_l2.obj",
    "C:\\Users\\정원준\\Desktop\\simulator\\cessna\\config.json",
    "C:\\Users\\정원준\\Desktop\\simulator\\style.css",
    "C:\\Users\\정원준\\Desktop\\simulator\\main.js",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\default\\",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\default\\config.json",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\default\\main.js",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\desert\\",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\desert\\config.json",
    "C:\\Users\\정원준\\Desktop\\simulator\\worlds\\desert\\main.js"
  ]
}