{
  "files": {
    "airplane.html": "<!DOCTYPE html>\n<html lang=\"ko\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <title>비행 시뮬레이터</title>\n    <link rel=\"stylesheet\" href=\"style.css\">\n</head>\n<body>\n    <div id=\"kill-counter\">Kills: 0</div>\n    <div id=\"hit-counter\">Hits: 0</div>\n    <div id=\"radar\"></div>\n    <aside id=\"controls\">\n        <p><b>조작법</b></p>\n        <p>위 화살표: 기수 내리기</p>\n        <p>아래 화살표: 기수 올리기</p>\n        <p>왼쪽 화살표: 좌회전</p>\n        <p>오른쪽 화살표: 우회전</p>\n        <p>스페이스바: 부스트</p>\n        <p><b>기체 변경</b></p>\n        <button onclick=\"changeAirplane('b-747')\">B-747</button>\n        <button onclick=\"changeAirplane('b-757')\">B-757</button>\n        <button onclick=\"changeAirplane('cessna')\">Cessna</button>\n        <p><b>지형 변경</b></p>\n        <button onclick=\"changeWorld('default')\">기본</button>\n        <button onclick=\"changeWorld('desert')\">사막</button>\n    </aside>\n    <div id=\"crosshair\"></div>\n    <main id=\"world\"></main>\n    <div id=\"speed-display\">Speed: 0 km/h</div>\n    <script src=\"https://cdnjs.cloudflare.com/ajax/libs/three.js/86/three.min.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.86.0/examples/js/loaders/OBJLoader.js\"></script>\n    <script src=\"https://cdn.jsdelivr.net/npm/three@0.86.0/examples/js/loaders/MTLLoader.js\"></script>\n    <script src=\"main.js\"></script>\n</body>\n</html>",
    "style.css": "* {\n    margin: 0;\n    padding: 0;\n}\n#world {\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    background: linear-gradient(#e4e0ba, #f7d9aa);\n}\n#controls {\n    position: absolute;\n    top: 10px;\n    right: 10px;\n    padding: 10px;\n    background-color: rgba(0,0,0,0.5);\n    color: white;\n    border-radius: 5px;\n    font-family: monospace;\n    z-index: 1000;\n}\n\n#speed-display {\n    position: absolute;\n    bottom: 20px;\n    right: 20px;\n    color: white;\n    font-size: 20px;\n    font-family: monospace;\n    z-index: 1000;\n}\n\n#kill-counter {\n    position: absolute;\n    top: 20px;\n    left: 50%;\n    transform: translateX(-50%);\n    color: white;\n    font-size: 24px;\n    font-family: monospace;\n    z-index: 1003;\n}\n\n#hit-counter {\n    position: absolute;\n    top: 50px;\n    left: 50%;\n    transform: translateX(-50%);\n    color: white;\n    font-size: 24px;\n    font-family: monospace;\n    z-index: 1003;\n}\n\n#crosshair {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    width: 20px;\n    height: 20px;\n    border: 2px solid white;\n    border-radius: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 1001;\n}\n\n#crosshair::before, #crosshair::after {\n    content: '';\n    position: absolute;\n    background-color: white;\n}\n\n#crosshair::before {\n    width: 2px;\n    height: 10px;\n    left: 9px;\n    top: -12px;\n}\n\n#crosshair::after {\n    height: 2px;\n    width: 10px;\n    top: 9px;\n    left: -12px;\n}\n\n#radar {\n    position: absolute;\n    top: 20px;\n    left: 20px;\n    width: 200px;\n    height: 200px;\n    background-color: rgba(0, 255, 0, 0.1);\n    border: 2px solid rgba(0, 255, 0, 0.5);\n    border-radius: 50%;\n    overflow: hidden;\n    z-index: 1002;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n}\n\n#radar .concentric-circle {\n    position: absolute;\n    border: 1px solid rgba(0, 255, 0, 0.3);\n    border-radius: 50%;\n}\n\n#radar .concentric-circle:nth-child(1) { width: 40px; height: 40px; }\n#radar .concentric-circle:nth-child(2) { width: 80px; height: 80px; }\n#radar .concentric-circle:nth-child(3) { width: 120px; height: 120px; }\n#radar .concentric-circle:nth-child(4) { width: 160px; height: 160px; }\n#radar .concentric-circle:nth-child(5) { width: 200px; height: 200px; }\n\n#radar .blip {\n    position: absolute;\n    width: 4px;\n    height: 4px;\n    background-color: red;\n    border-radius: 50%;\n}\n\n#radar::before, #radar::after {\n    content: '';\n    position: absolute;\n    background-color: rgba(0, 255, 0, 0.5);\n}\n\n#radar::before { /* Vertical line */\n    width: 2px;\n    height: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n}\n\n#radar::after { /* Horizontal line */\n    width: 100%;\n    height: 2px;\n    top: 50%;\n    transform: translateY(-50%);\n}",
    "main.js": "// 색상 객체: 재료의 색상 값을 일관성 있게 유지하고 쉽게 변경할 수 있도록 합니다.\nvar Colors = {\n    red: 0xf25346,\n    yellow: 0xedeb27,\n    white: 0xd8d0d1,\n    brown: 0x59332e,\n    pink: 0xF5986E,\n    brownDark: 0x23190f,\n    blue: 0x68c3c0,\n    green: 0x458248,\n    purple: 0x551A8B,\n    lightgreen: 0x629265,\n};\n\n// SCENE, CAMERA, RENDERER 및 Three.js 월드의 기타 전역 변수.\nvar scene, camera, fieldOfView, aspectRatio, nearPlane, farPlane, HEIGHT, WIDTH, renderer, container;\n\n// Three.js 씬, 카메라, 렌더러를 초기화합니다.\nfunction createScene() {\n    // 창의 높이와 너비를 가져와 종횡비와 렌더러 크기를 설정합니다.\n    HEIGHT = window.innerHeight;\n    WIDTH = window.innerWidth;\n\n    // 씬 객체를 생성합니다.\n    scene = new THREE.Scene();\n\n    // 깊이감을 위해 씬에 안개를 추가합니다. 색상은 배경과 일치합니다.\n    scene.fog = new THREE.Fog(0xf7d9aa, 100, 950);\n\n    // 카메라의 속성을 설정합니다.\n    aspectRatio = WIDTH / HEIGHT;\n    fieldOfView = 60; // 시야각 (도).\n    nearPlane = 1; // 렌더링될 카메라에 가장 가까운 객체.\n    farPlane = 10000; // 렌더링될 카메라에서 가장 먼 객체.\n    camera = new THREE.PerspectiveCamera(\n        fieldOfView,\n        aspectRatio,\n        nearPlane,\n        farPlane\n    );\n    \n    // 카메라의 초기 위치를 설정합니다.\n    camera.position.x = 0;\n    camera.position.z = 200;\n    camera.position.y = 100;\n\n    // WebGL 렌더러를 생성합니다.\n    renderer = new THREE.WebGLRenderer({\n        alpha: true, // 투명한 배경을 허용합니다.\n        antialias: true // 객체의 가장자리를 부드럽게 합니다 (성능 집약적일 수 있음).\n    });\n\n    // 렌더러의 크기를 창 크기와 일치하도록 설정합니다.\n    renderer.setSize(WIDTH, HEIGHT);\n    // 렌더러에서 그림자 매핑을 활성화합니다.\n    renderer.shadowMap.enabled = true;\n\n    // HTML에서 'world' div를 가져와 렌더러의 캔버스 요소를 추가합니다.\n    container = document.getElementById('world');\n    container.appendChild(renderer.domElement);\n\n    // 창 크기 조정 이벤트를 처리하기 위한 이벤트 리스너를 추가합니다.\n    window.addEventListener('resize', handleWindowResize, false);\n}\n\n// 씬의 비율을 유지하기 위해 창 크기 조정 이벤트를 처리합니다.\nfunction handleWindowResize() {\n    HEIGHT = window.innerHeight;\n    WIDTH = window.innerWidth;\n    renderer.setSize(WIDTH, HEIGHT);\n    camera.aspect = WIDTH / HEIGHT;\n    camera.updateProjectionMatrix(); // 카메라 속성 변경 후 호출해야 합니다.\n}\n\n// 조명\nvar hemisphereLight, shadowLight;\n\n// 씬의 조명을 설정합니다.\nfunction createLights() {\n    // 반구형 조명은 위아래에서 부드러운 주변 조명을 제공합니다.\n    hemisphereLight = new THREE.HemisphereLight(0xaaaaaa, 0x000000, .9)\n    \n    // 방향성 조명은 평행 광선을 투사하여 햇빛을 시뮬레이션합니다.\n    shadowLight = new THREE.DirectionalLight(0xffffff, .9);\n    shadowLight.position.set(150, 350, 350); // 조명 위치 설정.\n    shadowLight.castShadow = true; // 이 조명이 그림자를 드리우도록 활성화합니다.\n\n    // 그림자가 보이는 영역을 정의합니다.\n    shadowLight.shadow.camera.left = -400;\n    shadowLight.shadow.camera.right = 400;\n    shadowLight.shadow.camera.top = 400;\n    shadowLight.shadow.camera.bottom = -400;\n    shadowLight.shadow.camera.near = 1;\n    shadowLight.shadow.camera.far = 1000;\n\n    // 그림자 맵의 해상도를 설정합니다.\n    shadowLight.shadow.mapSize.width = 2048;\n    shadowLight.shadow.mapSize.height = 2048;\n\n    // 씬에 조명을 추가합니다.\n    scene.add(hemisphereLight);\n    scene.add(shadowLight);\n}\n\n// 비행기 객체 정의.\nvar airplaneConfigs = {\n    'b-747': { configPath: 'b-747/config.json' },\n    'b-757': { configPath: 'b-757/config.json' },\n    'cessna': { configPath: 'cessna/config.json' }\n};\n\nvar AirPlane = function (modelName, callback) {\n    this.mesh = new THREE.Object3D();\n    var self = this; // 'this' 컨텍스트를 유지합니다.\n\n    var configPath = airplaneConfigs[modelName].configPath;\n    fetch(configPath)\n        .then(response => response.json())\n        .then(config => {\n            self.config = config; // 나중에 사용하기 위해 config를 저장합니다.\n\n            var mtlLoader = new THREE.MTLLoader();\n            mtlLoader.setPath(modelName + '/');\n            mtlLoader.load(config.model.mtl, function (materials) {\n                materials.preload();\n                var objLoader = new THREE.OBJLoader();\n                objLoader.setMaterials(materials);\n                objLoader.setPath(modelName + '/');\n                objLoader.load(config.model.obj, function (object) {\n                    object.traverse(function (child) {\n                        if (child instanceof THREE.Mesh) {\n                            child.castShadow = true;\n                            child.receiveShadow = true;\n                        }\n                    });\n                    object.rotation.x = config.model.rotation.x;\n                    object.rotation.y = config.model.rotation.y;\n                    object.rotation.z = config.model.rotation.z;\n                    self.mesh.add(object);\n                    if (callback) callback();\n                });\n            });\n        });\n};\n\n// 지면 객체 정의.\nLand = function (config) {\n    var geom = new THREE.PlaneGeometry(20000, 20000, 1, 1);\n    geom.rotateX(-Math.PI / 2); // 평면을 수평으로 회전합니다.\n    var mat = new THREE.MeshPhongMaterial({\n        color: parseInt(config.landColor, 16),\n        shading: THREE.FlatShading,\n    });\n    this.mesh = new THREE.Mesh(geom, mat);\n    this.mesh.receiveShadow = true; // 지면은 그림자를 받아야 합니다.\n}\n\nvar worldObjectBlueprints = {};\n\n// 월드 객체 정의 (이전에는 숲).\nWorld = function (worldName, config) {\n    this.mesh = new THREE.Object3D();\n    var blueprints = worldObjectBlueprints[worldName];\n\n    if (config.objects && blueprints) {\n        config.objects.forEach(objConfig => {\n            var blueprint = blueprints[objConfig.type];\n            if (blueprint) {\n                for (let i = 0; i < objConfig.count; i++) {\n                    let obj = new blueprint();\n                    obj.mesh.position.x = (Math.random() - 0.5) * 4000;\n                    obj.mesh.position.y = 0;\n                    obj.mesh.position.z = (Math.random() - 0.5) * 4000;\n\n                    if (objConfig.type === 'building') {\n                        const sx = 20 + Math.random() * 30;\n                        const sy = 150 + Math.random() * 250;\n                        const sz = 20 + Math.random() * 30;\n                        obj.mesh.scale.set(sx, sy, sz);\n                        obj.mesh.position.y = sy / 2;\n                    } else {\n                        const s = (objConfig.type === 'tree') ? (.3 + Math.random() * .75) : (.1 + Math.random() * .3);\n                        obj.mesh.scale.set(s, s, s);\n                    }\n                    this.mesh.add(obj.mesh);\n                }\n            }\n        });\n    }\n}\n\n// 게임 객체 및 컨트롤을 위한 전역 변수.\nvar airplane;\nvar keys = {}; // 키보드 키 상태를 저장하는 객체.\nvar airplaneSpeed = 3; // 기본 속도는 이제 3배 빠릅니다.\nvar land;\nvar world; // forest에서 world로 변경됨\nvar yawAngle = 0; // 좌우 회전 각도.\nvar pitchAngle = 0; // 상하 회전 각도.\nvar kills = 0; // 격추 횟수\nvar hits = 0; // 맞힌 횟수\n\n// AI 관련 전역 변수\nvar aiAircrafts = [];\nvar worldBoundary = 2000;\n\n// 키보드 입력에 대한 이벤트 리스너.\ndocument.addEventListener('keydown', handleKeyDown, false);\ndocument.addEventListener('keyup', handleKeyUp, false);\n\n// 키가 눌렸을 때 키 상태를 true로 설정합니다.\nfunction handleKeyDown(event) {\n    keys[event.key] = true;\n\n    if (event.key === '1') {\n        changeAirplane('b-747');\n    }\n    if (event.key === '2') {\n        changeAirplane('b-757');\n    }\n\n    if (event.key === 'Control' && !isFiring) {\n        startFiring();\n    }\n}\n\n// 키가 놓였을 때 키 상태를 false로 설정합니다.\nfunction handleKeyUp(event) {\n    keys[event.key] = false;\n\n    if (event.key === 'Control') {\n        stopFiring();\n    }\n}\n\nvar bullets = [];\nvar fireInterval;\nvar isFiring = false;\n\nfunction startFiring() {\n    if (!airplane || !airplane.config || !airplane.config.machineGun) return;\n    isFiring = true;\n    fireInterval = setInterval(createBullet, airplane.config.machineGun.fireRate);\n}\n\nfunction stopFiring() {\n    isFiring = false;\n    clearInterval(fireInterval);\n}\n\nfunction createBullet() {\n    if (!airplane || !airplane.config || !airplane.config.machineGun) return;\n\n    var machineGunConfig = airplane.config.machineGun;\n    var bulletGeometry = new THREE.ConeGeometry(machineGunConfig.bulletSize, machineGunConfig.bulletLength, 4); // 4 for sharper cone\n    var bulletMaterial = new THREE.MeshBasicMaterial({ color: parseInt(machineGunConfig.bulletColor, 16) });\n    var bullet = new THREE.Mesh(bulletGeometry, bulletMaterial);\n\n    var forwardVector = new THREE.Vector3(1, 0, 0);\n    forwardVector.applyQuaternion(airplane.mesh.quaternion);\n\n    bullet.position.copy(airplane.mesh.position);\n    bullet.quaternion.copy(airplane.mesh.quaternion);\n    bullet.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), -Math.PI / 2));\n\n    bullet.previousPosition = bullet.position.clone(); // 이전 위치 저장\n\n    var bulletSpeed = airplane.config.performance.speed * machineGunConfig.bulletSpeedMultiplier;\n    bullet.velocity = forwardVector.multiplyScalar(bulletSpeed);\n\n    scene.add(bullet);\n    bullets.push(bullet);\n}\n\nfunction updateBullets() {\n    for (var i = bullets.length - 1; i >= 0; i--) {\n        var bullet = bullets[i];\n        bullet.previousPosition.copy(bullet.position); // 현재 위치를 이전 위치로 업데이트\n        bullet.position.add(bullet.velocity);\n\n        // 총알과 AI 항공기 충돌 감지 (Raycasting)\n        var hitObjects = aiAircrafts.map(a => a.hitBoxMesh).filter(m => m !== undefined);\n        \n        var direction = bullet.velocity.clone();\n        if (direction.lengthSq() === 0) { // Check for zero vector\n            // console.warn(\"Bullet velocity is zero, skipping raycast.\");\n            continue; // Skip this bullet if velocity is zero\n        }\n        direction.normalize(); // Normalize only if not zero\n\n        var raycaster = new THREE.Raycaster(bullet.previousPosition, direction);\n        var intersects = raycaster.intersectObjects(hitObjects);\n\n        if (intersects.length > 0) { // 충돌 발생\n            // 충돌한 객체가 어떤 AI 항공기의 것인지 찾습니다.\n            var hitAiPlane = null;\n            for (var k = 0; k < aiAircrafts.length; k++) {\n                if (aiAircrafts[k].hitBoxMesh === intersects[0].object) {\n                    hitAiPlane = aiAircrafts[k];\n                    break;\n                }\n            }\n\n            if (hitAiPlane) {\n                scene.remove(bullet);\n                bullets.splice(i, 1);\n\n                hitAiPlane.health -= 10;\n                hits++;\n                document.getElementById('hit-counter').innerText = 'Hits: ' + hits;\n\n                if (hitAiPlane.health <= 0) {\n                    scene.remove(hitAiPlane.mesh);\n                    scene.remove(hitAiPlane.healthBar); // 체력바 제거\n                    scene.remove(hitAiPlane.hitBoxMesh); // 피격 판정 영역 메시 제거\n                    // aiAircrafts 배열에서 제거\n                    for (var k = 0; k < aiAircrafts.length; k++) {\n                        if (aiAircrafts[k] === hitAiPlane) {\n                            aiAircrafts.splice(k, 1);\n                            break;\n                        }\n                    }\n                    createAiAircraft(); // 새 AI 항공기 생성\n                    kills++;\n                    document.getElementById('kill-counter').innerText = 'Kills: ' + kills;\n                }\n            }\n            // 총알 하나는 하나의 비행기만 맞출 수 있습니다.\n            continue; // 다음 총알로 넘어감\n        }\n\n        // 화면 밖으로 나가면 총알 제거\n        if (bullet.position.x > 10000 || bullet.position.x < -10000 ||\n            bullet.position.y > 10000 || bullet.position.y < -10000 ||\n            bullet.position.z > 10000 || bullet.position.z < -10000) {\n            scene.remove(bullet);\n            bullets.splice(i, 1);\n        }\n    }\n}\n\nfunction updateAiAircrafts() {\n    var radar = document.getElementById('radar');\n    radar.innerHTML = ''; // 이전 블립 제거\n\n    // 기존 블립만 제거 (동심원과 지시선은 유지)\n    var blips = radar.querySelectorAll('.blip');\n    blips.forEach(function(blip) {\n        blip.remove();\n    });\n\n    aiAircrafts.forEach(function(aiPlane) {\n        if (!aiPlane.mesh) return;\n\n        // AI 로직 (이전과 동일) - 일시적으로 비활성화\n        /*\n        if (Math.random() > 0.99) {\n            aiPlane.mesh.rotation.y += (Math.random() - 0.5) * 0.5;\n        }\n        if (aiPlane.mesh.position.x > worldBoundary || aiPlane.mesh.position.x < -worldBoundary ||\n            aiPlane.mesh.position.z > worldBoundary || aiPlane.mesh.position.z < -worldBoundary) {\n            var direction = new THREE.Vector3(0, aiPlane.mesh.position.y, 0).sub(aiPlane.mesh.position).normalize();\n            aiPlane.mesh.quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), direction);\n        }\n        var forwardVector = new THREE.Vector3(1, 0, 0);\n        forwardVector.applyQuaternion(aiPlane.mesh.quaternion);\n        aiPlane.mesh.position.add(forwardVector.multiplyScalar(aiPlane.config.performance.speed));\n        */\n\n        // 피격 판정 영역 메시 위치 업데이트\n        if (aiPlane.hitBoxMesh) {\n            aiPlane.hitBoxMesh.position.copy(aiPlane.mesh.position);\n        }\n\n        // 체력바 업데이트 (이전과 동일)\n        if (aiPlane.healthBar) {\n            aiPlane.healthBar.position.copy(aiPlane.mesh.position).add(new THREE.Vector3(0, -20, 0)); // 항공기 아래에 위치\n            const distance = camera.position.distanceTo(aiPlane.mesh.position);\n            const healthBarWidth = 0.5; // px, 1에서 0.5로 줄여 길이를 절반으로 조정\n            const scale = (healthBarWidth / window.innerWidth) * distance * Math.tan(camera.fov * Math.PI / 360) * 2;\n            aiPlane.healthBar.scale.x = (aiPlane.health / 100) * scale;\n            aiPlane.healthBar.scale.y = scale / 10;\n            aiPlane.healthBar.scale.z = 1;\n            aiPlane.healthBar.lookAt(camera.position);\n        }\n\n        // 레이더에 적기 위치 표시\n        var relativePos = aiPlane.mesh.position.clone().sub(airplane.mesh.position);\n\n        // 내 기체의 회전(quaternion)을 사용하여 적기의 상대 위치를 변환합니다.\n        // 레이더는 수평적인 관계만 표시해야 하므로, yawAngle만 사용합니다.\n        var playerYawQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawAngle);\n        var inversePlayerYawQuaternion = playerYawQuaternion.inverse();\n        var localPos = relativePos.clone().applyQuaternion(inversePlayerYawQuaternion);\n\n        // 레이더 좌표로 변환 (12시 방향이 정면, X는 오른쪽, Z는 앞)\n        // 레이더 크기 200px, 중앙 100px\n        // 비행기 로컬 좌표계: +X 전방, +Y 상방, +Z 우측\n        var radarX = 100 + (localPos.z / worldBoundary) * 100; // localPos.z는 우측/좌측 (레이더 X축)\n        var radarY = 100 - (localPos.x / worldBoundary) * 100; // localPos.x는 전방/후방 (레이더 Y축, 화면 Y축은 반전)\n\n        // 레이더 범위 내에 있을 때만 표시\n        if (Math.abs(localPos.x) < worldBoundary && Math.abs(localPos.z) < worldBoundary) {\n            var blip = document.createElement('div');\n            blip.className = 'blip';\n            blip.style.left = radarX + 'px';\n            blip.style.top = radarY + 'px';\n            blip.style.backgroundColor = aiPlane.config.future_expansion.radarColor; // config에서 색상 로드\n            radar.appendChild(blip);\n        } else { // 레이더 범위 밖에 있을 때\n            // 적기의 방향을 레이더 외곽에 표시\n            var angle = Math.atan2(localPos.z, localPos.x); // localPos.z는 X축, localPos.x는 Y축\n            var radius = 95; // 레이더 원의 반지름 (100px - blip 크기)\n\n            var blip = document.createElement('div');\n            blip.className = 'blip';\n            blip.style.width = '2px';\n            blip.style.height = '2px';\n            blip.style.backgroundColor = aiPlane.config.future_expansion.radarColor; // config에서 색상 로드\n            blip.style.borderRadius = '50%';\n            blip.style.position = 'absolute';\n\n            // 각도를 화면 좌표에 매핑: 12시 (위)는 -Y, 3시 (오른쪽)는 +X\n            blip.style.left = (100 + radius * Math.sin(angle)) + 'px';\n            blip.style.top = (100 - radius * Math.cos(angle)) + 'px'; // 화면 Y축은 아래로 갈수록 증가하므로 반전\n            radar.appendChild(blip);\n        }\n    });\n}\n\n// 비행기를 생성하고 씬에 추가합니다.\nfunction createPlane(modelName, callback) {\n    airplane = new AirPlane(modelName, function() {\n        var scale = airplane.config.model.scale || 0.0125; // config에 없으면 기본값 사용\n        airplane.mesh.scale.set(scale, scale, scale); \n        airplane.mesh.position.y = 100;\n        scene.add(airplane.mesh);\n        if (callback) callback();\n    });\n}\n\n// 지면을 생성하고 씬에 추가합니다.\nfunction createLand(config) {\n    land = new Land(config);\n    land.mesh.position.y = 0;\n    scene.add(land.mesh);\n}\n\n// 월드를 생성하고 씬에 추가합니다.\nfunction createWorld(worldName, config) {\n    world = new World(worldName, config);\n    world.mesh.position.y = 0;\n    scene.add(world.mesh);\n}\n\nfunction createAiAircraft() {\n    var modelNames = Object.keys(airplaneConfigs);\n    var randomModelName = modelNames[Math.floor(Math.random() * modelNames.length)];\n\n    var aiPlane = new AirPlane(randomModelName, function() {\n        var scale = aiPlane.config.model.scale || 0.0125; // config에 없으면 기본값 사용\n        aiPlane.mesh.scale.set(scale, scale, scale); \n        aiPlane.mesh.position.x = (Math.random() - 0.5) * worldBoundary;\n        aiPlane.mesh.position.y = 100 + Math.random() * 200;\n        aiPlane.mesh.position.z = (Math.random() - 0.5) * worldBoundary;\n\n        // 체력바 추가\n        var healthBarGeometry = new THREE.BoxGeometry(100, 10, 10);\n        var healthBarMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000 });\n        var healthBar = new THREE.Mesh(healthBarGeometry, healthBarMaterial);\n        aiPlane.healthBar = healthBar;\n        aiPlane.health = aiPlane.config.combat.health; // config에서 체력 로드\n\n        // AI 속도 관리: AI 속도를 플레이어 기본 속도보다 낮게 설정\n        if (airplane && airplane.config) {\n            aiPlane.config.performance.speed = 1 + Math.random() * (airplane.config.performance.speed - 1);\n        } else {\n            // 플레이어 항공기 설정이 아직 로드되지 않은 경우 (createPlane 호출 후에는 발생하지 않아야 함)\n            aiPlane.config.performance.speed = 1 + Math.random() * 2; // 기본 랜덤 속도\n        }\n\n        // 피격 판정 영역 시각화 (THREE.Mesh)\n        var hitBoxSize = aiPlane.config.combat.hitboxSize * 2; // config에서 피격 크기 로드\n        var hitBoxGeometry = new THREE.BoxGeometry(hitBoxSize, hitBoxSize, hitBoxSize);\n        var hitBoxMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.2, wireframe: true }); // 녹색, 투명, 와이어프레임\n        var hitBoxMesh = new THREE.Mesh(hitBoxGeometry, hitBoxMaterial);\n        aiPlane.hitBoxMesh = hitBoxMesh;\n        scene.add(hitBoxMesh);\n\n        scene.add(aiPlane.mesh);\n        scene.add(healthBar); // 씬에 직접 추가\n        aiAircrafts.push(aiPlane);\n    });\n}\n\nfunction changeWorld(worldName) {\n    var worldPath = 'worlds/' + worldName + '/';\n    var configPath = worldPath + 'config.json';\n    var scriptPath = worldPath + 'main.js';\n\n    // 스크립트 로더\n    var script = document.createElement('script');\n    script.src = scriptPath;\n    script.onload = function() {\n        fetch(configPath)\n            .then(response => response.json())\n            .then(config => {\n                if (land && land.mesh) {\n                    scene.remove(land.mesh);\n                }\n                if (world && world.mesh) {\n                    scene.remove(world.mesh);\n                }\n                scene.fog = new THREE.Fog(parseInt(config.fogColor, 16), 100, 950);\n                createLand(config);\n                createWorld(worldName, config);\n            });\n    };\n    document.head.appendChild(script);\n}\n\n// 사용자 입력에 따라 비행기의 위치와 회전을 업데이트합니다.\nfunction updatePlane() {\n    if (!airplane || !airplane.config) return; // 비행기 또는 설정이 로드되지 않았으면 아무것도 하지 않습니다.\n\n    var pitchSpeed = airplane.config.performance.turnSensitivity;\n    var turnSpeed = airplane.config.performance.turnSensitivity;\n    var maxPitch = 80 * Math.PI / 180; // 80도 (라디안).\n\n    // 키보드 입력에 따라 피치 및 요 각도를 업데이트합니다.\n    if (keys[\"ArrowDown\"]) { // 아래쪽 화살표는 기수를 올립니다.\n        pitchAngle = Math.min(maxPitch, pitchAngle + pitchSpeed);\n    }\n    if (keys[\"ArrowUp\"]) { // 위쪽 화살표는 기수를 내립니다.\n        pitchAngle = Math.max(-maxPitch, pitchAngle - pitchSpeed);\n    }\n    if (keys[\"ArrowLeft\"]) { // 왼쪽 화살표는 왼쪽으로 요합니다.\n        yawAngle += turnSpeed;\n    }\n    if (keys[\"ArrowRight\"]) { // 오른쪽 화살표는 오른쪽으로 요합니다.\n        yawAngle -= turnSpeed;\n    }\n\n    // 요 및 피치 회전을 위한 쿼터니언을 생성합니다.\n    var yawQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), yawAngle);\n    var pitchQ = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), pitchAngle);\n\n    // 회전을 결합합니다: 먼저 요를 적용한 다음 피치를 적용합니다.\n    // 이렇게 하면 위/아래 피칭이 비행기의 현재 요 방향에 상대적으로 이루어집니다.\n    airplane.mesh.quaternion.copy(yawQ).multiply(pitchQ);\n\n    // 스페이스바가 눌렸는지 여부에 따라 현재 속도와 프로펠러 회전을 결정합니다.\n    var currentSpeed = airplane.config.performance.speed;\n    if (keys[\" \"]) { // 스페이스바는 키 코드 32이지만, \" \"가 더 읽기 쉽습니다.\n        currentSpeed *= airplane.config.performance.boostMultiplier;\n    }\n\n    // 현재 방향을 따라 비행기를 앞으로 이동시킵니다.\n            var forwardVector = new THREE.Vector3(1, 0, 0); // 로컬 전방 방향은 +X.\n            forwardVector.applyQuaternion(airplane.mesh.quaternion); // 월드 공간으로 변환.\n            airplane.mesh.position.add(forwardVector.multiplyScalar(currentSpeed));\n        }\n\n// 메인 애니메이션 루프.\nfunction loop() {\n    // 비행기 상태를 업데이트합니다.\n    updatePlane();\n    updateBullets();\n    updateAiAircrafts();\n\n    // 카메라가 비행기를 뒤에서 약간 위에서 따라가도록 설정합니다.\n    var relativeCameraOffset = new THREE.Vector3(-800, 800, 0); // 더 먼 거리를 위해 X 조정\n    var cameraOffset = relativeCameraOffset.applyMatrix4(airplane.mesh.matrixWorld);\n\n    // 카메라를 새 오프셋 위치로 부드럽게 이동시킵니다.\n    camera.position.lerp(cameraOffset, 0.1);\n    camera.up.set(0, 1, 0); // 카메라의 위쪽 방향을 월드의 위쪽과 정렬합니다.\n    \n    // 카메라가 비행기 앞의 지점을 바라보도록 합니다.\n    var lookAtTarget = new THREE.Vector3(1, 0, 0);\n    lookAtTarget.applyQuaternion(airplane.mesh.quaternion);\n    lookAtTarget.multiplyScalar(500);\n    lookAtTarget.add(airplane.mesh.position);\n    camera.lookAt(lookAtTarget);\n\n    // 카메라 시점에서 씬을 렌더링합니다.\n    renderer.render(scene, camera);\n    // 다음 애니메이션 프레임을 요청합니다.\n    requestAnimationFrame(loop);\n}\n\nfunction changeAirplane(modelName) {\n    if (airplane && airplane.mesh) {\n        scene.remove(airplane.mesh);\n    }\n    pitchAngle = 0;\n    yawAngle = 0;\n    createPlane(modelName, function() {\n        // 비행기가 로드된 후 필요한 경우 추가 작업을 수행합니다.\n    });\n}\n\n// 초기화 함수.\nfunction init(event) {\n    createScene();\n    createLights();\n    createRadar(); // 레이더 생성 함수 호출\n    createPlane('b-747', function() {\n        changeWorld('default');\n        for (var i = 0; i < 10; i++) {\n            createAiAircraft();\n        }\n        loop(); // 비행기가 로드된 후 애니메이션 루프를 시작합니다.\n    });\n}\n\n// 페이지가 완전히 로드되면 애플리케이션을 시작합니다.\nwindow.addEventListener('load', init, false);\n\nfunction createRadar() {\n    var radar = document.getElementById('radar');\n    // 동심원 생성\n    for (var i = 0; i < 5; i++) {\n        var circle = document.createElement('div');\n        circle.className = 'concentric-circle';\n        radar.appendChild(circle);\n    }\n}",
    "b-747\\config.json": "{\n  \"model\": {\n    \"mtl\": \"11803_Airplane_v1_l1.mtl\",\n    \"obj\": \"11803_Airplane_v1_l1.obj\",\n    \"rotation\": {\n      \"x\": 1.5707963267948966,\n      \"y\": 3.141592653589793,\n      \"z\": 3.141592653589793\n    },\n    \"scale\": 0.0125\n  },\n  \"performance\": {\n    \"speed\": 3,\n    \"turnSensitivity\": 0.025,\n    \"boostMultiplier\": 2\n  },\n  \"combat\": {\n    \"attack\": 10,\n    \"defense\": 10,\n    \"health\": 100,\n    \"hitboxSize\": 100,\n    \"ammo\": {\n      \"weapon1\": 100,\n      \"weapon2\": 50,\n      \"weapon3\": 10\n    }\n  },\n  \"future_expansion\": {\n    \"radarColor\": \"blue\"\n  },\n  \"machineGun\": {\n    \"bulletSpeedMultiplier\": 56,\n    \"bulletSize\": 2,\n    \"bulletLength\": 160,\n    \"bulletColor\": \"0xffffff\",\n    \"fireRate\": 100\n  }\n}",
    "b-757\\config.json": "{\n  \"model\": {\n    \"mtl\": \"11803_Airplane_v1_l1.mtl\",\n    \"obj\": \"11803_Airplane_v1_l1.obj\",\n    \"rotation\": {\n      \"x\": 1.5707963267948966,\n      \"y\": 3.141592653589793,\n      \"z\": 3.141592653589793\n    },\n    \"scale\": 0.0125\n  },\n  \"performance\": {\n    \"speed\": 6,\n    \"turnSensitivity\": 0.05,\n    \"boostMultiplier\": 4\n  },\n  \"combat\": {\n    \"attack\": 10,\n    \"defense\": 10,\n    \"health\": 120,\n    \"hitboxSize\": 120,\n    \"ammo\": {\n      \"weapon1\": 100,\n      \"weapon2\": 50,\n      \"weapon3\": 10\n    }\n  },\n  \"future_expansion\": {\n    \"radarColor\": \"green\"\n  }\n}",
    "cessna\\config.json": "{\n  \"model\": {\n    \"mtl\": \"11804_Airplane_v2_l2.mtl\",\n    \"obj\": \"11804_Airplane_v2_l2.obj\",\n    \"rotation\": {\n      \"x\": 1.5707963267948966,\n      \"y\": 3.141592653589793,\n      \"z\": 0\n    },\n    \"scale\": 0.0125\n  },\n  \"performance\": {\n    \"speed\": 3,\n    \"turnSensitivity\": 0.025,\n    \"boostMultiplier\": 2\n  },\n  \"combat\": {\n    \"attack\": 10,\n    \"defense\": 10,\n    \"health\": 100,\n    \"hitboxSize\": 50,\n    \"ammo\": {\n      \"weapon1\": 100,\n      \"weapon2\": 50,\n      \"weapon3\": 10\n    }\n  },\n  \"future_expansion\": {\n    \"radarColor\": \"yellow\"\n  }\n}",
    "worlds\\default\\config.json": "{\n  \"landColor\": \"0x629265\",\n  \"fogColor\": \"0xf7d9aa\",\n  \"objects\": [\n    { \"type\": \"tree\", \"count\": 300 },\n    { \"type\": \"flower\", \"count\": 200 },\n    { \"type\": \"building\", \"count\": 100 }\n  ]\n}",
    "worlds\\default\\main.js": "var petalColors = [0xf25346, 0xedeb27, 0x68c3c0];\n\nworldObjectBlueprints.default = {\n    'tree': function() {\n        this.mesh = new THREE.Object3D();\n        var matTreeLeaves = new THREE.MeshPhongMaterial({ color: 0x458248, shading: THREE.FlatShading });\n        var geonTreeBase = new THREE.BoxGeometry(10, 20, 10);\n        var matTreeBase = new THREE.MeshBasicMaterial({ color: 0x59332e });\n        var treeBase = new THREE.Mesh(geonTreeBase, matTreeBase);\n        treeBase.castShadow = true;\n        treeBase.receiveShadow = true;\n        this.mesh.add(treeBase);\n        var geomTreeLeaves1 = new THREE.CylinderGeometry(1, 12 * 3, 12 * 3, 4);\n        var treeLeaves1 = new THREE.Mesh(geomTreeLeaves1, matTreeLeaves);\n        treeLeaves1.castShadow = true;\n        treeLeaves1.receiveShadow = true;\n        treeLeaves1.position.y = 20;\n        this.mesh.add(treeLeaves1);\n        var geomTreeLeaves2 = new THREE.CylinderGeometry(1, 9 * 3, 9 * 3, 4);\n        var treeLeaves2 = new THREE.Mesh(geomTreeLeaves2, matTreeLeaves);\n        treeLeaves2.castShadow = true;\n        treeLeaves2.position.y = 40;\n        treeLeaves2.receiveShadow = true;\n        this.mesh.add(treeLeaves2);\n        var geomTreeLeaves3 = new THREE.CylinderGeometry(1, 6 * 3, 6 * 3, 4);\n        var treeLeaves3 = new THREE.Mesh(geomTreeLeaves3, matTreeLeaves);\n        treeLeaves3.castShadow = true;\n        treeLeaves3.position.y = 55;\n        treeLeaves3.receiveShadow = true;\n        this.mesh.add(treeLeaves3);\n    },\n    'flower': function() {\n        this.mesh = new THREE.Object3D();\n        var geomStem = new THREE.BoxGeometry(5, 50, 5, 1, 1, 1);\n        var matStem = new THREE.MeshPhongMaterial({ color: 0x458248, shading: THREE.FlatShading });\n        var stem = new THREE.Mesh(geomStem, matStem);\n        stem.castShadow = false;\n        stem.receiveShadow = true;\n        this.mesh.add(stem);\n        var geomPetalCore = new THREE.BoxGeometry(10, 10, 10, 1, 1, 1);\n        var matPetalCore = new THREE.MeshPhongMaterial({ color: 0xedeb27, shading: THREE.FlatShading });\n        var petalCore = new THREE.Mesh(geomPetalCore, matPetalCore);\n        petalCore.castShadow = false;\n        petalCore.receiveShadow = true;\n        var petalColor = petalColors[Math.floor(Math.random() * 3)];\n        var geomPetal = new THREE.BoxGeometry(15, 20, 5, 1, 1, 1);\n        var matPetal = new THREE.MeshBasicMaterial({ color: petalColor });\n        geomPetal.vertices[5].y -= 4;\n        geomPetal.vertices[4].y -= 4;\n        geomPetal.vertices[7].y += 4;\n        geomPetal.vertices[6].y += 4;\n        geomPetal.translate(12.5, 0, 3);\n        var petals = [];\n        for (var i = 0; i < 4; i++) {\n            petals[i] = new THREE.Mesh(geomPetal, matPetal);\n            petals[i].rotation.z = i * Math.PI / 2;\n            petals[i].castShadow = true;\n            petals[i].receiveShadow = true;\n        }\n        petalCore.add(petals[0], petals[1], petals[2], petals[3]);\n        petalCore.position.y = 25;\n        petalCore.position.z = 3;\n        this.mesh.add(petalCore);\n    },\n    'building': function() {\n        this.mesh = new THREE.Object3D();\n        var geom = new THREE.BoxGeometry(1, 1, 1);\n        var mat = new THREE.MeshPhongMaterial({ color: 0xd8d0d1, shading: THREE.FlatShading });\n        var building = new THREE.Mesh(geom, mat);\n        building.castShadow = true;\n        building.receiveShadow = true;\n        this.mesh.add(building);\n    }\n};\n",
    "worlds\\desert\\config.json": "{\n  \"landColor\": \"0xd2b48c\",\n  \"fogColor\": \"0xf0e68c\",\n  \"objects\": []\n}",
    "worlds\\desert\\main.js": "// 사막 지형을 위한 객체들을 이곳에 추가할 수 있습니다.\nworldObjectBlueprints.desert = {};"
  },
  "summary": "이 프로젝트는 웹 기반 3D 비행 시뮬레이터입니다. 사용자는 다양한 비행기 모델을 선택하고, 여러 환경에서 비행을 시뮬레이션할 수 있습니다. 주요 기능으로는 비행기 조작, 총알 발사, AI 적기와의 전투, 그리고 레이더 시스템이 있습니다. 레이더는 플레이어의 위치를 중심으로 적기의 상대적인 위치를 표시하며, 적기 종류에 따라 다른 색상으로 표시됩니다. 레이더의 탐지 거리는 조절 가능하며, AI 적기의 속도도 플레이어의 경험에 맞춰 조정됩니다.",
  "last_updated": "2025-08-01T12:00:00Z"
}